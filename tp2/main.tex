\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=3cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{ifthen}
\usepackage{libs/caratula}
\usepackage{libs/aed2-symb,libs/aed2-itef,libs/aed2-tad}
\usepackage{fixltx2e}
\usepackage{caption}
\usepackage{algpseudocode}
\usepackage[section]{algorithm}
\usepackage[colorlinks=false, linkcolor=blue]{hyperref}
\usepackage{calc}

%%--- Nuevos comandos START

\MakeRobust{\Call}
\algdef{SL}{var}{0}[2]{$#1$ \textbf{es} \TipoVariable{#2}}

\newcommand{\f}[1]{\text{#1}}
\renewcommand{\paratodo}[2]{$\forall~#2$: #1}

\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Justificacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Justificaci\'on de la elecci\'on de la estructura}%
  \vspace*{2ex}%
}{}

\newcommand{\modTitulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{
  \par\vspace*{2ex}
  \hypertarget{#1}{}
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}
  \par\vspace*{1ex}
}{
  \par\vspace*{2ex}
}

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

%%--- Nuevos comandos END

\sloppy

\parskip=5pt % 10pt es el tamaño de fuente

% Pongo en 0 la distancia extra entre itemes.
\let\olditemize\itemize
\def\itemize{\olditemize\itemsep=0pt}

% Acomodo fancyhdr.
\pagestyle{fancy}
\thispagestyle{fancy}
\addtolength{\headheight}{1pt}
\lhead{Algoritmos y Estructuras de Datos II}
\rhead{$2^{\mathrm{do}}$ cuatrimestre de 2012}
\cfoot{\thepage /\pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}

\author{Grupo 3 - Algoritmos y Estructuras de Datos II, 2do Cuatrimestre 2012.}
\date{}
\title{LinkLinkIt}

\begin{document}

\materia{Algoritmos y Estructuras de Datos II}
\submateria{Trabajo Pr\'actico de Dise\~no}
\titulo{LinkLinkIt}
\subtitulo{Cat\'alogo de rutas en internet}
\grupo{3}
\integrante{Barabas, Ariel}{775/11}{ariel.baras@gmail.com}
\integrante{Izcovich, Sabrina}{550/11}{sizcovich@gmail.com}
\integrante{Otero, Fernando}{424/11}{fergabot@gmail.com}
\integrante{Vita, Sebasti\'an}{149/11}{sebastian\_vita@yahoo.com.ar}

%Pagina de titulo e indice
\thispagestyle{empty}

\maketitle
\tableofcontents
\newpage

\section{M\'odulo DiccTrie($\alpha$)}
\subsection{Interfaz}

	\textbf{par\'ametro formal}: \TipoVariable{$\alpha$}.

	\textbf{usa}: \TipoVariable{Nat, Bool, String}.

	\textbf{se explica con}: \TipoVariable{Diccionario(String, $\alpha$)}.

	\textbf{g\'eneros}: \TipoVariable{diccTrie($\alpha$)}.

	\modTitulo{Operaciones b\'asicas}

	\InterfazFuncion{Vacio}{}{diccTrie($\alpha$)}
	  {$res \igobs vacio()$}
	  [O(1)]
	  [Genera un diccionario vac\'io.]

	\InterfazFuncion{Definir}{\Inout{d}{diccTrie($\alpha$)}, \In{k}{string}, \In{s}{$\alpha$}}{}
	  [$d \igobs d_0$]
	  {$d \igobs definir(k, s, d_0)$}
	  [O(|$k$|)]
	  [Define la clave $k$ con el significado $s$ en el diccionario.]
	  [La clave se guarda por copia y el significado por referencia.]

	\InterfazFuncion{Definido?}{\Inout{d}{diccTrie($\alpha$)}, \In{k}{string}}{Bool}
	  {$res \igobs def?(k, d)$}
	  [O(|$k$|)]
	  [Devuelve \TipoVariable{True} s\'i y s\'olo s\'i $k$ est\'a definido en el diccionario.]

	\InterfazFuncion{Obtener}{\Inout{d}{diccTrie($\alpha$)}, \In{k}{string}}{$\alpha$}
	  [$def?(k, d)$]
	  {$alias(res \igobs obtener(k, d))$}
	  [O(|$k$|)]
	  [Devuelve el significado por referencia de la clave $k$ en $d$.]

\subsection{Representaci\'on}

	\begin{Estructura}{diccTrie($\alpha$)}
	    \begin{Tupla}
	      \tupItem{trie}{puntero(nodo)}
	    \end{Tupla}

	    \begin{Tupla}[nodo]
	      \tupItem{hijo}{puntero(nodo)}
	      \tupItem{hermano}{puntero(nodo)}
	      \tupItem{elem}{puntero($\alpha$)}
	      \tupItem{letra}{char}
	    \end{Tupla}
	\end{Estructura}

\tadAlinearAxiomas{Rep(e)}
\Rep[diccTrie($\alpha$)][e]{}\mbox{}

\begin{Justificacion}

\end{Justificacion}

\modTitulo{Operacion Auxiliar}

	\InterfazFuncion{crearNodo}{\In {c}{char}}{nodo}
	  {$res.hijo \igobs \TipoVariable{NULL} \land res.hermano \igobs \TipoVariable{NULL} \land res.elem \igobs \TipoVariable{NULL} \land res.letra \igobs c$}
	  [O(1)]
	  [Genera un nodo con todos los punteros a \TipoVariable{NULL} y con el char que se pasa como par\'ametro almacenado en $letra$.]

\subsection{Algoritmos}

\begin{algorithm}[H]
\caption*{iCrearNodo(\In{c}{char}) $\DRef res$ : \TipoVariable{nodo}}
\begin{algorithmic}[1]
	\State $res.elem \gets \TipoVariable{NULL}$ \Comment{O(1)}
	\State $res.hijo \gets \TipoVariable{NULL}$ \Comment{O(1)}
	\State $res.hermano \gets \TipoVariable{NULL}$ \Comment{O(1)}
	\State $res.letra \gets c$ \Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $4O(1) = O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iVacio() $\DRef res$ : \TipoVariable{diccTrie($\alpha$)}}
\begin{algorithmic}[1]
	\State $res.trie \gets \TipoVariable{NULL}$ \Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iDefinir(\Inout{d}{diccTrie($\alpha$)}, \In {k}{string}, \In{s}{$\alpha$)}}
\begin{algorithmic}[1]
	\State $cargoTodo \gets d.trie = \TipoVariable{NULL}$\Comment{O(1)}
	\State $i \gets 0$\Comment{O(1)}
	\Statex
	\var{nodo}{nodo}
	\If {$cargoTodo$}
		\State $nodo \gets \Call{crearNodo}{k[i]}$ \Comment{O(1)}
		\State $i++$\Comment{O(1)}
	\Else
		\State $nodo \gets *d.trie$	
	\EndIf
	\Statex	
	\Statex // Se toma el primer nodo. Si $cargoTodo$, entonces en el bucle se crear\'an todos los nodos hasta formar $k$. En caso contrario se ir\'a recorriendo todo el \'arbol hasta encontrar el lugar donde habr\'a que colocar el resto de los caracteres de $k$ que no est\'en en el \'arbol.	
	\Statex
	\While{$i < \Call{longitud}{k}$}\Comment{$256 * O(|k|) * O(1) = O(|k|)$}
		\If{cargoTodo}
			\State $nodoVacio \gets \Call{crearNodo}{k[i]}$\Comment{O(1)}
			\State $nodo.hijo \gets \&nodoVacio$ \Comment{O(1)}
			\State $nodo \gets nodoVacio$ \Comment{O(1)}
			\State $i \gets i + 1$\Comment{O(1)}	
		\Else
					
			\If {$nodo.letra = k[i]$}    	
    			\If {$nodo.hijo = \TipoVariable{NULL}$}
					\State $cargoTodo \gets \TipoVariable{True}$\Comment{O(1)}
					\State $i \gets i + 1$\Comment{O(1)}	
				\Else    			
    				\State $nodo \gets *nodo.hijo$\Comment{O(1)}
					\State $i \gets i + 1$\Comment{O(1)}	
    			\EndIf
			\Else
				\If{$nodo.hermano \neq \TipoVariable{NULL}$} 
					\State $nodo \gets *nodo.hermano$\Comment{O(1)}
				\Else
					\State $nodoVacio \gets \Call{crearNodo}{k[i]}$\Comment{O(1)}
					\State $nodo.hermano \gets \&nodoVacio$ \Comment{O(1)}
					\State $nodo \gets nodoVacio$ \Comment{O(1)}
					\State $i \gets i + 1$\Comment{O(1)}	
					\State $cargoTodo \gets \TipoVariable{True}$\Comment{O(1)}
				\EndIf
			\EndIf
		\EndIf
 	\EndWhile
	\Statex		
	\State $nodo.elem \gets \&s$ \Comment{O(1)}	
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $3O(1) + O(|k|) = O(|k)$
\\ \tab El bucle, en el peor caso (cargoTodo es False y el caracter a buscar es el que tiene ord = 255 y en ese nivel est\'an todos los caracteres del 0 al 254), tiene que hacer 256 ciclos pero como este es un valor finito, no arruina nuestra complejidad.
\end{algorithm}

\begin{algorithm}[H]
\caption*{iDefinido?(\Inout{d}{diccTrie($\alpha$)}, \In{k}{string} $\DRef res$ : \TipoVariable{Bool}}
\begin{algorithmic}[1]
	\var{nodo}{nodo}
	\State $i \gets 0$\Comment{O(1)}
	\Statex
	\If {d.trie = \TipoVariable{NULL}}
		\State $res \gets \TipoVariable{False}$\Comment{O(1)}
		\State $i \gets \Call{longitud}{k}$\Comment{O(1)}
	\Else
		\State $nodo \gets *d.trie$\Comment{O(1)}
	\EndIf	\Comment{O(1)}
	\Statex	
	\While{$i < \Call{longitud}{k}$}\Comment{$256 * O(|k|) * O(1) = O(|k|)$}					
		\If {$nodo.letra = k[i]$}    	
    		\If {$i + 1 = \Call{longitud}{k}$}
				\State $res \gets \TipoVariable{True}$\Comment{O(1)}
				\State $i \gets i + 1$\Comment{O(1)}
			\Else    			
				\If{$nodo.hijo = \TipoVariable{NULL}$}    			
   		 			\State $res \gets \TipoVariable{False}$\Comment{O(1)}
   		 			\State $i \gets \Call{longitud}{k}$\Comment{O(1)}
   		 		\Else
   		 			\State $nodo \gets *nodo.hijo$\Comment{O(1)}
					\State $i \gets i + 1$\Comment{O(1)}
    			\EndIf
    		\EndIf
		\Else
			\If{$nodo.hermano \neq \TipoVariable{NULL}$} 
				\State $nodo \gets *nodo.hermano$\Comment{O(1)}
			\Else
				\State $res \gets \TipoVariable{False}$\Comment{O(1)}
				\State $i \gets \Call{longitud}{k}$\Comment{O(1)}
			\EndIf
		\EndIf
 	\EndWhile
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $2O(1) + O(|k|) = O(|k|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iObtener(\Inout{d}{diccTrie($\alpha$)}, \In{k}{string} $\DRef res$ : \TipoVariable{$\alpha$}}
\begin{algorithmic}[1]
	\State $nodo \gets *d.trie$\Comment{O(1)}
	\State $i \gets 0$\Comment{O(1)}
	\Statex
	\While{$i < \Call{longitud}{k}$}\Comment{$256 * O(|k|) * O(1) = O(|k|)$}					
		\If {$nodo.letra = k[i]$}    	
    		\If {$i + 1 = \Call{longitud}{k}$}
				\State $res \gets *nodo.elem$\Comment{O(1)}
			\Else    			
				\State $nodo \gets *nodo.hijo$\Comment{O(1)}	
    		\EndIf
			\State $i \gets i + 1$\Comment{O(1)}
		\Else
			\State $nodo \gets *nodo.hermano$\Comment{O(1)}
		\EndIf
 	\EndWhile
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $2O(1) + O(|k|) = O(|k|)$   
\end{algorithm}
 
\subsection{Servicios Usados}

\textbf{Los siguientes m\'odulos deben cumplir los compromisos pedidos}

\begin{itemize}
	\item \TipoVariable{Puntero($\alpha$)}
	\begin{itemize}
		\item La función * debe tener complejidad O(1).
		\item La función \& debe tener complejidad O(1).
	\end{itemize}

	\item \TipoVariable{Vector($\alpha$)}
	\begin{itemize}
		\item La función Longitud debe tener complejidad O(1).
		\item La función $\bullet[\bullet]$ debe tener complejidad O(1).
	\end{itemize}
\end{itemize}

\section{M\'odulo ArbolCategorias}
\subsection{Interfaz}

    \textbf{usa}: \TipoVariable{Nat, String, diccTrie($\alpha$), lista($\alpha$), iteradorUni($\alpha$)}.

	\textbf{se explica con}: \TipoVariable{ArbolCategorias, Iterador Unidireccional($\alpha$)}.

	\textbf{g\'eneros}: \TipoVariable{abCat}, \TipoVariable{itabCat}.

	\modTitulo{Operaciones b\'asicas}

	\InterfazFuncion{nuevoAC}{\In{raiz}{categoria}}{abCat}
	  {$res \igobs nuevo(raiz)$}
	  [$\Theta(|raiz|)$]
	  [Crea un \'arbol con categor\'ia \emph{raiz}.]

	\InterfazFuncion{raiz}{\In{ac}{abCat}}{categoria}
	  {$res \igobs raiz(ac)$}
	  [$\Theta(1)$]
	  [Devuelve el nombre de la categor\'ia raiz por referencia, con lo cual, si \'este valor es modificado, se romper\'a el invariante de representaci\'on invalidando todo el \'arbol.]

	\InterfazFuncion{agregar}{\Inout{ac}{abCat}, \In{padre}{categoria}, \In{hija}{categoria}}{}
	  [$ac \igobs ac_0 \land \emph{est\'a}?(padre, ac) \land \neg\emph{vac\'ia}?(hija) \land \neg\emph{est\'a}?(hija, ac)$]
	  {$ac \igobs agregar(ac_0, padre, hija)$}
	  [$\Theta(|padre| + |hija|)$]
	  [Agrega la categor\'ia hija a padre.]

	\InterfazFuncion{hijas}{\In{ac}{abCat}, \In{padre}{categoria}}{iteradorUni(categoria)}
	  [$\emph{est\'a}?(padre, ac)$]
	  {$res \igobs crearItUni(conjuntoASecuencia(hijos(ac, padre)))$}
	  [$\Theta(|padre|)$]
	  [Devuelve un iterador que proyecta las hijas del padre de forma tal que, al pedir actual, el iterador devuelve el primer elemento de la lista.]
	  [El iterador se invalida s\'i y s\'olo s\'i se elimina el elemento siguiente del iterador.]

    \InterfazFuncion{padres}{\In{ac}{abCat}, \In{hija}{categoria}}{itabCat}
      [$\emph{est\'a}?(hija, ac)$]
	  {$res \igobs crearItUni(padres(ac, hija))$}
	  [$\Theta(|hija|)$]
	  [Devuelve un iterador que proyecta los id's de los padres de forma tal que, al pedir ActualID, el iterador devuelve el id de la hija.]

	\InterfazFuncion{ID}{\In{ac}{abCat}, \In{c}{categoria}}{Nat}
	  [$\emph{est\'a}?(c, ac)$]
	  {$res \igobs id(ac, c)$}
	  [$\Theta(|c|)$]
	  [Devuelve el id de la categor\'ia dada.]

	\InterfazFuncion{cantCategorias}{\In{ac}{abCat}}{Nat}
	  {$res \igobs \#categorias(ac)$}
	  [$\Theta(1)$]
	  [Devuelve la cantidad de categor\'ias existentes en el \'arbol.]


\modTitulo{Funciones auxiliares}

	\tadOperacion{conjuntoASecuencia}{Conjunto($\alpha$)}{Secuencia($\alpha$)}{}
	\tadAlinearAxiomas{conjuntoASecuencia(c)}
    \tadAxioma{conjuntoASecuencia(c)}{\IF $\emptyset$?(c) THEN <> ELSE dameUno(c) $\bullet$ conjuntoASecuencia(sinUno(c)) FI}

    \tadOperacion{padres}{acat\ $ac$, categoria\ $hija$}{Secuencia(Nat)}{est\'a?(hija, ac)}
    %\tadAlinearAxiomas{padres($ac$, $hija$)}
	\tadAxioma{padres($ac$, $hija$)}{\IF $hija$ \igobs raiz($ac$) THEN 1 $\bullet$ <> ELSE id($ac$, $hija$) $\bullet$ padres($ac$, padre($ac$, $hija$)) FI}

\modTitulo{Operaciones del iterador}

   	\InterfazFuncion{HayMasPadres?}{\In{it}{itabCat}}{Bool}
	  {$res \igobs HayMas?(it)$}
	  [$\Theta(1)$]
	  [Devuelve true s\'i y s\'olo s\'i en el iterador todav\'ia quedan elementos por iterar.]

	\InterfazFuncion{Subir}{\Inout{it}{itabCat}}{}
	  [$hayMas?(it) \land it \igobs it_0$]
	  {$it \igobs Avanzar(it_0)$}
	  [$\Theta(1)$]
	  [Avanza el iterador a la siguiente posici\'on.]
	  
	 \InterfazFuncion{ActualID}{\In{it}{itabCat}}{$Nat$}
	  {$res \igobs Actual(it)$}
	  [$\Theta(1)$]
	  [Devuelve el id del elemento al que est\'a apuntando.]
	
\subsection{Representaci\'on}

	\begin{Estructura}{abCat}
	    \begin{Tupla}
	      \tupItem{categorias}{DiccTrie(categoria, catInfo)}
	      \tupItem{raiz}{categoria}
	      \tupItem{ultID}{Nat}
	    \end{Tupla}

	    \begin{Tupla}[catInfo]
	      \tupItem{id}{Nat}
	      \tupItem{padre}{puntero(catInfo)}
	      \tupItem{hijas}{lista(categoria)}
	    \end{Tupla}
	\end{Estructura}

\tadAlinearAxiomas{Rep(e)}
\Rep[abcat][e]{$1 \yluego 2 \land 3 \yluego 4 \yluego 5 \yluego 6 \land 7 \land 8 \land 9 \land 10$}\mbox{}

{\bf Donde:}

ACLARACI\'ON: Llamaremos a la operaci\'on $"$esta?$"$ (definida en el TAD secuencia) $"$estaLista?$"$ para no generar confusiones.\\ 
\begin{enumerate}
  \item El id de la ra\'iz del \'arbol es 1 (requerido por el enunciado del TP).\\
        {\bf Formalmente:} $id(e.raiz) = 1$
        

  \item No existe ninguna categor\'ia incluida en sus categor\'ias hijas.\\
        {\bf Formalmente:} $(\forall c:categoria)esta?(c,claves(e.categorias)) \impluego \neg(estaLista?(c,hijas(c)))$

  \item Todas las categor\'ias tienen padre, excluyendo la ra\'iz.\\
        {\bf Formalmente:} $(\forall c:categoria)(esta?(c,claves(e.categorias)) \land (c\not=e.raiz)) \impluego ((\exists t:categoria)(esta?(t,claves(e.categorias)) \land t\not=c) \yluego estaLista?(c,hijas(t)))$

  \item Existe una categor\'ia que no tiene padre y que es igual a ra\'iz.\\
        {\bf Formalmente:} $(\forall c:categoria)esta?(c,claves(e.categorias)) \impluego \neg(estaLista?(c,hijas(c)))$
  	     
  \item Cada categor\'ia tiene un \'unico padre (este \'item (junto con el 2,3 y
  4) garantiza que el \'arbol no sea c\'iclico) (esto supuestamente queda expl\'icito pues el padre es un puntero).\\
        {\bf Formalmente:} $\neg(\exists t,c:categoria)((esta?(c,claves(e.categorias))) \yluego (esta?(t,claves(e.categorias)))$ $\yluego (t\not=c)) \yluego ((\forall k:categoria)esta?(k,claves(e.categorias)) \impluego (estaLista?(k,hijas(c)) \yluego estaLista?(k,hijas(t)))$
  
  \item La cantidad de categor\'ias totales es igual a UltId.\\
        {\bf Formalmente:} $\#claves(e.categorias) = e.ultId$
  
  \item Las categor\'ias hijas de cada categor\'ia tienen un id mayor a \'esta.\\
        {\bf Formalmente:} $((\forall c:categoria)esta?(c,claves(e.categorias))) \impluego ((\forall t:categoria)(esta?(c,claves(e.categorias)) \yluego estaLista?(t,hijas(c))) \impluego id(c)<id(t))$
  
  \item No existen dos IDs iguales para categor\'ias distintas.\\
        {\bf Formalmente:} $(\forall c,t:categoria)(esta?(c,claves(e.categorias)) \land esta?(t,claves(e.categorias)) \land t\not=c) \impluego id(c)\not=id(t)$
        
  \item Ningún padre es Null salvo el de la raíz. \\
  		{\bf Formalmente:} $(\forall t:categoria)(esta?(c,claves(e.categorias)) \land (t\not=e.raiz)) \impluego padre(t)\not=Null$
  		
  \item El padre de la raíz es Null.  \\
  {\bf Formalmente:} $*padre(e.raiz) = Null$
  
  %\item Dada una categoría que pertenece a una lista de hijas, su categoría padre apunta al padre (necesario?)
    
\end{enumerate}

  \AbsFc[estr]{abcat}{e.raiz = raiz(a) $\land$ ($\forall$ c:categoria)esta?(c,e.claves(categorias)) $\impluego$ id(e,c) = id(c,a) $\land$ ($\forall$ c:categoria)esta?(c,e) $\impluego$  }

\begin{Justificacion}
\\Para representar el árbol de categorías elegimos esta estructura por los siguientes motivos:
\\En primer lugar, el Diccionario Trie modulariza perfectamente un \'arbol de categor\'ias dado que es posible conocer los hijos de cada una de las categor\'ias con la complejidad requerida, para esto, se coloco en cada nodo una lista con los nombres de cada hijo. 
\\En segundo lugar, esta estructura nos permite acceder a la ra\'iz del arbol en O(1) y al ID de cada categor\'ia en O(|c|) donde c es el nombre de la categor\'ia.
\\El iterador que recorre el arbol hacia arriba será necesario en el LinkLinkIt
\end{Justificacion}

\subsection{Iterador}

	\begin{Estructura}{itabCat}
	    \begin{Tupla}
	      \tupItem{iterador}{puntero(Info)}
	    \end{Tupla}

	    \begin{Tupla}[Info]
	      \tupItem{id}{Nat}
	      \tupItem{padre}{puntero(catInfo)}
	      \tupItem{hijas}{lista(categoria)}
	    \end{Tupla}
	\end{Estructura}

\tadAlinearAxiomas{Rep(e)}
\Rep[itabcat][e]{}\mbox{}

\begin{Justificacion}

\end{Justificacion}

\subsection{Algoritmos}

\begin{algorithm}[H]
\caption*{iNuevoAC(\In{raiz}{categoria}) $\DRef res$ : \TipoVariable{abCat}}
\begin{algorithmic}[1]
	\State $res.categorias \gets$ \Call{Vacio}{\null}\Comment{O(1)}
	\State $res.raiz \gets raiz$\Comment{O(|$raiz$|)}
	\State $res.ultID \gets 1$\Comment{O(1)}
	\Statex
	\var{infoPadre}{catInfo}
	\State $infoPadre.id \gets 0$\Comment{O(1)}
	\State $infoPadre.padre \gets NULL$\Comment{O(1)}
	\State $infoPadre.hijas \gets$ \Call{Vacia}{\null}\Comment{O(1)}
	\Statex
	\var{infoRaiz}{catInfo}
	\State $infoRaiz.id \gets res.ultID$\Comment{O(1)}
	\State $infoRaiz.padre \gets \&infoPadre$\Comment{O(1)}
	\State $infoRaiz.hijas \gets$ \Call{Vacia}{\null}\Comment{O(1)}
	\State \Call{Definir}{$res.categorias, raiz, infoRaiz$}\Comment{O(|$raiz$|)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $9O(1) + 2O(|raiz|) = O(|raiz|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iRaiz(\In{ac}{abCat}) $\DRef res$ : \TipoVariable{categoria}}
\begin{algorithmic}[1]
	\State $res \gets ac.raiz$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iAgregar(\Inout{ac}{abCat}, \In{padre}{categoria}, \In{hija}{categoria})}
\begin{algorithmic}[1]
	\State $ac.ultID \gets ac.ultID + 1$\Comment{O(1)}
	\State $infoPadre \gets$ \Call{Obtener}{$ac.categorias, padre$}\Comment{O(|$padre$|)}
	\Statex
	\var{infoHija}{catInfo}
	\State $infoHija.id \gets ac.ultID$\Comment{O(1)}
	\State $infoHija.padre \gets \&infoPadre$\Comment{O(1)}
	\State $infoHija.hijas \gets$ \Call{Vacia}{\null}\Comment{O(1)}
	\State \Call{Definir}{$ac.categorias, hija, infoHija$}\Comment{O(|$hija$|)}
	\Statex
	\State \Call{AgregarAtras}{$infoPadre.hijas, hija$}\Comment{O(|$hija$|)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $4O(1) + 2O(|hija|) + O(|padre|) = O(|hija|) + O(|padre|) = O(|hija| + |padre|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iHijas(\In{ac}{abCat}, \In{padre}{categoria}) $\DRef res$ : \TipoVariable{iteradorUni(categoria)}}
\begin{algorithmic}[1]
    \State $nodoHijo \gets \Call{Obtener}{ac.categorias, padre}$\Comment{O(|$padre$|)}
	\State $res \gets \Call{crearIterador}{nodoHijo.hijas}$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|padre|) + O(1) = O(|padre|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iPadres(\In{ac}{abCat}, \In{hija}{categoria}) $\DRef res$ : \TipoVariable{itabCat}}
\begin{algorithmic}[1]
    \State $nodoHija \gets \Call{Obtener}{ac.categorias, hija}$\Comment{O(|$hija$|)}
    \State $iterador \gets \&nodoHija$\Comment{O(1)}
    \State $res \gets iterador$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|hija|) + 2O(1) = O(|hija|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iID(\In{ac}{abCat}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $catInfo \gets$ \Call{Obtener}{$ac.categorias, c$}\Comment{O(|$c$|)}
	\State $res \gets catInfo.id$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|c|) + O(1) = O(|c|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iCantCategorias(\In{ac}{abCat}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $res \gets ac.ultId$\Comment{$O(1)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\subsubsection{Algoritmos del Iterador}

\begin{algorithm}[H]
\caption*{iHayMasPadres?(\In{it}{itabCat}) $\DRef res$ : \TipoVariable{Bool}}
\begin{algorithmic}[1]
	\State $res \gets it.padre \neq \TipoVariable{NULL}$\Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iSubir(\Inout{it}{itabCat})}
\begin{algorithmic}[1]
	\State $it \gets \&it.padre$ \Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iActualID(\In{it}{itabCat}) $\DRef res$ : {$Nat$}}
\begin{algorithmic}[1]
	\State $res \gets it.id$ \Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\subsection{Servicios Usados}

\textbf{Los siguientes m\'odulos deben cumplir los compromisos pedidos}

\begin{itemize}
	\item \TipoVariable{Lista Enlazada ($\alpha$)}
	\begin{itemize}
		\item[Vacia] debe tener complejidad O(1).
		\item[AgregarAtras] debe tener complejidad O($copy$($a$)), donde $a$ es el tipo del elemento que se va a colocar en la lista.
	\end{itemize}

	\item \TipoVariable{Iterador Unidireccional ($\alpha$)}
	\begin{itemize}
		\item[crearIterador] debe tener complejidad O(1).
	\end{itemize}

	\item \TipoVariable{DiccTrie ($\alpha$)}
	\begin{itemize}
		\item[Vacio] debe tener complejidad O(1).
		\item[Definir] debe tener complejidad O(|$k$|) donde $k$ es el string que se va a colocar por definici\'on.
		\item[Obtener] debe tener complejidad O(|$k$|) donde $k$ es la clave.
	\end{itemize}

	\item \TipoVariable{Puntero ($\alpha$)}
	\begin{itemize}
		\item[\&] debe tener complejidad O(1).
	\end{itemize}
\end{itemize}

\section{M\'odulo LinkLinkIt}

\subsection{Interfaz}
	
	\InterfazFuncion{crearLinkLinkIt}{\In{ac}{abCat}}{LinkLinkIt}
	  {$res \igobs iniciar(ac)$}
	  [$\Theta(\#categorias(ac))$]
	  [Crea un sistema LinkLinkIt. El \'arbol de categor\'ias se guarda por refencia.]

	\InterfazFuncion{agregarLink}{\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{c}{categoria}}{}
	  [$s \igobs s_0$ $\land$ $l \notin links(s)$ $\land$ \emph{est\'a}?$(c, categorias(s))$]
	  {$s \igobs nuevoLink(s_0, l, c)$}
	  [$\Theta(|l| + |c| + h)$]
	  [Agrega un link a la categor\'ia se\~{n}alada.]

	\InterfazFuncion{accederLink}{\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{f}{fecha}}{}
	  [$s \igobs s_0$ $\land$ $l \in$ links($s$) $\land$ $f \geq$ fechaActual($s$)]
	  {$s \igobs acceso(s_0, l, f)$}
	  [$\Theta(|l|)$]
	  [Registra un acceso al link provisto.]

	\InterfazFuncion{cantLinks}{\In{s}{LinkLinkIt}, \In{c}{categoria}}{Nat}
	  {$res \igobs cantLinks(s, c)$}
	  [$\Theta(|c|)$]
	  [Devuelve la cantidad de links que tiene una categor\'ia y sus hijas.]

    \InterfazFuncion{linksOrdenadosPorAccesos}{\Inout{s}{LinkLinkIt}, \In{c}{categoria}}{itLinks}
	  [$\emph{est\'a}?(c, categorias(s))$]
	  {$res \igobs crearIt(secuInfoLinks(s, c))$}
	  [$\Theta(|c| + n^2)$]
	  [Devuelve la cantidad de links que tiene una categor\'ia.]

    \InterfazFuncion{puntajeDelLink}{\In{il}{infoLink}, \In{f}{fecha}}{Nat}
	  [$il.ultAcceso \leq f$]
	  {$res \igobs ???$}
	  [$\Theta(1)$]
	  [Devuelve el puntaje del link. Esta funci\'on es privada ya que recibe una estructura interna.]

\modTitulo{Funciones auxiliares}

	\tadOperacion{secuInfoLinks}{lli\ s, categoria\ c}{secu(tupla(link, categoria, Nat))}{est\'a?(c, categorias(s))}
	\tadAlinearAxiomas{secuInfoLinks(s, c)}
	\tadAxioma{secuInfoLinks(s, c)}{infoLinks(s, c, linksOrdenadosPorAccesos(s, c))}
	
	\tadOperacion{infoLinks}{lli\ s, categoria\ c, secu(link)\ ls}{secu(tupla(link, categoria, Nat))}{est\'a?(c, categorias(s)) $\land$ ($\forall$ l:link)(est\'a?(l, ls) $\Rightarrow$ l $\in$ links(s) $\land$ esSubCategoria(categorias(s), c, categoriaLink(s, l)))}
	\tadAlinearAxiomas{infoLinks(s, c, ls)}
	\tadAxioma{infoLinks(s, c, ls)}{\IF Vacia(ls) THEN <> ELSE
					tupla(prim(ls), categoriaLink(s, prim(ls)), accesosRecientes(s, c, prim(ls))) $\bullet$ infoLinks(s, c, fin(ls))
				FI}

\modTitulo{Operaciones del iterador}

	\InterfazFuncion{CrearItLinks}{\In{ls}{lista(infoLink), \In{f}{fecha}}}{itLinks}
	  [$(\forall\ l:infoLink)(\emph{est\'a}?(l, ls) \Rightarrow l.ultAcceso \leq f)$]
	  {$res \igobs \Pi_1(Siguiente(it))$}
	  [$O(1)$]

	\InterfazFuncion{SiguienteLink}{\In{it}{itLinks}}{link}
	  [$HaySiguiente?(it)$]
	  {$res \igobs \Pi_1(Siguiente(it))$}
	  [$O(1)$]

	\InterfazFuncion{SiguienteCategoria}{\In{it}{itLinks}}{categoria}
	  [$HaySiguiente?(it)$]
	  {$res \igobs \Pi_2(Siguiente(it))$}
	  [$O(1)$]

	\InterfazFuncion{SiguienteAccesosRecientes}{\In{it}{itLinks}}{Nat}
	  [$HaySiguiente?(it)$]
	  {$res \igobs \Pi_3(Siguiente(it))$}
	  [$O(1)$]

	\InterfazFuncion{HaySiguiente}{\In{it}{itLinks}}{Bool}
	  {$res \igobs HaySiguiente?(it)$}
	  [$O(1)$]

	\InterfazFuncion{Avanzar}{\Inout{it}{itLinks}}{}
	  [$it = it_0 \land HaySiguiente?(it)$]
	  {$it \igobs Avanzar(it_0)$}
	  [$O(1)$]

\subsection{Representaci\'on}

\begin{Estructura}{LinkLinkIt}
    \begin{Tupla}
      \tupItem{aCategorias}{abcat}
      \tupItem{\\ linksPorCat}{vector(lista(puntero(infoLink)))}
      \tupItem{\\ infoLinks}{DiccTrie(link, infoLink)}
    \end{Tupla}

	\begin{Tupla}[infoLink]
		\tupItem{link}{link}
		\tupItem{categoria}{categoria}
    	\tupItem{ultAcceso}{fecha}
		\tupItem{accesos}{vector(Nat)}
	\end{Tupla}
\end{Estructura}

\tadAlinearAxiomas{Rep(e)}
\Rep[LinkLinkIt][e]{}\mbox{}

\subsection{Iterador}

\begin{Estructura}{itLinks}
	\begin{Tupla}
		\tupItem{it}{itLista(link)}
		\tupItem{fecha}{fecha}
	\end{Tupla}
\end{Estructura}

\subsection{Algoritmos}

\begin{algorithm}[H]
\caption*{iCrearLinkLinkIt(\In{ac}{abCat}) $\DRef res$ : \TipoVariable{\hyperlink{LinkLinkIt}{LinkLinkIt}}}
\begin{algorithmic}[1]
	\State $res.aCategorias \gets ac$\Comment{$\Theta$(1)}
	\State $res.linksPorCat \gets \Call{Vacia}{\null}$\Comment{$\Theta$(1)}
	\State $res.infoLinks \gets \Call{Vacio}{\null}$\Comment{$\Theta$(1)}
	\Statex
	\For {$i = 1 \to \Call{cantCategorias}{ac}$} \Comment{$O(1) + \#categorias(ac) * \Theta(1) = \Theta(\#categorias(ac))$}
	\State $\Call{AgregarAtras}{res.linksPorCat, \Call{Vacia}{\null}}$\Comment{$\Theta(1)$}
	\EndFor
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $3\Theta(1) + \Theta(\#categorias(ac)) = \Theta(\#categorias(ac))$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iAgregarLink(\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{c}{categoria})}
\begin{algorithmic}[1]
	\State $categoriaID \gets \Call{ID}{s.aCategorias, c}$\Comment{O(|c|)}
	\Statex
	\var{info}{infoLink}
	\State $info.link \gets l$\Comment{O(|l|)}
	\State $info.categoria \gets c$\Comment{O(|c|)}
    \State $info.ultAcceso \gets 0$\Comment{O(1)}
    \For{$i = 1 \to 3$}\Comment{3O(1) = O(1)}
        \State $\Call{AgregarAtras}{info.accesos, 0}$\Comment{O(1)}
    \EndFor
	\State $\Call{Definir}{s.infoLinks, l, info}$\Comment{O(|$l$|)}
    \State $\Call{AgregarAtras}{s.linksPorCat[categoriaID-1], \&info}$\Comment{$O(1)$}
	\Statex
	\State $it \gets \Call{padres}{s.aCategorias, c}$\Comment{O(|c|)}
	\While{$\Call{HayMasPadres?}{it}$}\Comment{$(O(h) + O(1)) * 3O(1) = O(h)$}
    	\State $\Call{Subir}{it}$\Comment{O(1)}
    	\State $categoriaID \gets \Call{ActualID}{s, categoriaID}$\Comment{$O(1)$}
		\State $\Call{AgregarAtras}{s.linksPorCat[categoriaID-1], \&info}$\Comment{$O(1)$}
	\EndWhile
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1) + 3O(|c|) + 2O(|l|) + O(h) = O(|c|) + O(|l|) + O(h) = O(|c| + |l| + h)$
\\ \tab El bucle tiene $h$ iteraciones ya que inicia en un nodo y luego, en cada ciclo, se va subiendo hasta la raiz del \'arbol.
\end{algorithm}

\begin{algorithm}[H]
\caption*{iAccederLink(\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{f}{fecha})}
\begin{algorithmic}[1]
	\State $link \gets \Call{Obtener}{s.infoLinks, l}$\Comment{$O(|l|)$}
    \State $diff \gets f - link.ultAcceso$\Comment{$O(1)$}
    \Statex
    \Statex // Muevo hacia atr\'as los d\'ias que pasaron
    \State $i \gets 0$\Comment{$O(1)$}
    \While{$i < 3 - diff$}\Comment{$3 * 2O(1) = O(1)$}
        \State $link.accesos[i] \gets link.accesos[i + diff]$\Comment{$2O(1) = O(1)$}
        \State $i \gets i + 1$\Comment{$O(1)$}
    \EndWhile
    \Statex
    \Statex // Pongo en 0 los nuevos d\'ias que llegaron
    \State $i \gets 0$\Comment{O(1)}
    \While{$i < diff \land i < 3$}\Comment{$3 * 2O(1) = O(1)$}
        \State $link.accesos[2 - i] \gets 0$\Comment{$O(1)$}
        \State $i \gets i + 1$\Comment{$O(1)$}
    \EndWhile
    \Statex
    \State $link.ultAcceso \gets f$\Comment{$O(1)$}
    \State $link.accesos[2] \gets link.accesos[2] + 1$\Comment{$2O(1) = O(1)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $7O(1) + O(|l|) = O(|l|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iCantLinks(\In{s}{LinkLinkIt}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $categoriaID \gets \Call{ID}{s.aCategorias, c}$\Comment{$O(|c|)$}
	\State $res \gets \Call{Longitud}{s.linksPorCat[categoriaID-1]}$\Comment{$2O(1) = O(1)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|c|) + O(1) = O(|c|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iLinksOrdenadosPorAccesos(\Inout{s}{LinkLinkIt}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{\hyperlink{itLinks}{itLinks}}}
\begin{algorithmic}[1]
    \State $categoriaID \gets \Call{ID}{s.aCategorias, c}$\Comment{$O(|c|)$}
    \State $lista \gets s.linksPorCat[categoriaID - 1]$\Comment{$O(1)$}
    \Statex
    \Statex // Encuentro la fecha m\'as alta de esta categor\'ia.
    \State $it \gets \Call{crearIt}{lista}$\Comment{$O(1)$}
    \State $f \gets 0$\Comment{$O(1)$}
    \While{$\Call{HaySiguiente}{it}$}\Comment{$nO(1) = O(n)$}
        \State $f \gets \Call{max}{\Call{Siguiente}{it}.ultAcceso, f}$\Comment{$O(1)$}
        \State $\Call{Avanzar}{it}$\Comment{$O(1)$}
    \EndWhile
    \Statex
	\Statex // Ya está ordenado?
	\State $it \gets \Call{crearIt}{lista}$
	\State $estaOrdenada \gets \TipoVariable{True}$
	\State $ultPuntaje \gets -1$
	\While{$\Call{HaySiguiente}{it} \land estaOrdenada$}\Comment{$(n + O(1)) * 2O(1) = O(n)$}
		\If{$ultPuntaje > -1$}
			\State $estaOrdenada \gets ultPuntaje \geq \Call{puntajeDelLink}{\Call{Siguiente}{it}, f}$\Comment{2O(1)}
		\EndIf
		\State $ultPuntaje \gets \Call{puntajeDelLink}{\Call{Siguiente}{it}, f}$\Comment{2O(1)}
	\EndWhile
	\If{$estaOrdenada$}
		\State \Return $res \gets \Call{crearItLinks}{lista}$\Comment{O(1)}
	\EndIf
	\Statex
	\Statex // Ordeno agregando $n$ veces el de m\'as accesos que encuentre.
	\State $listaOrdenada \gets \Call{Vacia}{\null}$
	\State $itOrd \gets \Call{crearIt}{listaOrdenada}$
	\While{$\neg\Call{Vacia}{lista}$}\Comment{$n * (O(n) + 3O(1)) = O(n^2)$}
		\State $itRes \gets itMaxAccesos \gets \Call{crearIt}{lista}$\Comment{2O(1) = O(1)}
		\While{$\Call{HaySiguiente}{itRes}$}\Comment{$n * 5O(1) = O(n)$}
			\If{$\Call{puntajeDelLink}{\Call{Siguiente}{itRes}, f} > \Call{puntajeDelLink}{\Call{Siguiente}{itMaxAccesos}, f}$}
				\State $itMaxAccesos \gets itRes$
			\EndIf
		\EndWhile
		\Statex
		\State $\Call{AgregarComoAnterior}{itOrd, \Call{Siguiente}{itMaxAccesos}}$\Comment{O(1)}
		\State $\Call{EliminarSiguiente}{itMaxAccesos}$\Comment{O(1)}
		\Statex
	\EndWhile
	\Statex
	\State $s.linksPorCat[categoriaID-1] \gets listaOrdenada$\Comment{O(1)}
	\State $res \gets \Call{crearItLinks}{listaOrdenada}$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|c|) + 2O(n) + O(n^2) + 11O(1)= O(|c| + n^2)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iPuntajeDelLink(\In{il}{infoLink}, \In{ultAccesoCat}{fecha}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
    \State $res \gets 0$\Comment{$O(1)$}
    \State $i \gets 3$\Comment{$O(1)$}
    \While{$f - il.ultAcceso < i$}\Comment{gracias a la Pre $(f - il.ultAcceso) > 0 \Rightarrow 3O(1) = O(1)$}
        \State $i \gets i - 1$\Comment{$O(1)$}
        \State $res \gets res + il.accesos[i]$\Comment{$O(1)$}
    \EndWhile
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $3O(1) = O(1)$
\end{algorithm}

\subsubsection{Algoritmos del Iterador}

\begin{algorithm}[H]
\caption*{iCrearItLinks(\In{ls}{lista(link)}, fecha) $\DRef res$ : \TipoVariable{\hyperlink{itLinks}{itLinks}}}
\begin{algorithmic}[1]
	\State $res.it \gets \Call{crearIt}{ls}$\Comment{O(1)}
	\State $res.fecha \gets fecha$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iSiguienteLink(\In{itl}{itLinks}) $\DRef res$ : \TipoVariable{link}}
\begin{algorithmic}[1]
	\State $res \gets \Call{Siguiente}{itl.it}.link$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iSiguienteCategoria(\In{itl}{itLinks}) $\DRef res$ : \TipoVariable{categoria}}
\begin{algorithmic}[1]
	\State $res \gets \Call{Siguiente}{itl.it}.categoria$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iSiguienteAccesosRecientes(\In{itl}{itLinks}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $res \gets \Call{puntajeDelLink}{\Call{Siguiente}{itl.it}, itl.fecha}$\Comment{2O(1) = O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iHaySiguiente?(\In{itl}{itLinks}) $\DRef res$ : \TipoVariable{Bool}}
\begin{algorithmic}[1]
	\State $res \gets \Call{HaySiguiente?}{itl.it} \yluego \Call{puntajeDelLink}{\Call{Siguiente}{itl.it}, itl.fecha} > 0$\Comment{3O(1) = O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iAvanzar(\Inout{itl}{itLinks})}
\begin{algorithmic}[1]
	\State $\Call{Avanzar}{itl.it}$
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1) = O(1)$
\end{algorithm}

\subsection{Servicios Usados}

\textbf{Los siguientes m\'odulos deben cumplir los compromisos pedidos}

\begin{itemize}
	\item \TipoVariable{Puntero($\alpha$)}
	\begin{itemize}
		\item[\&] debe tener complejidad O(1).
	\end{itemize}

	\item \TipoVariable{abCat}
	\begin{itemize}
		\item[cantCategorias] debe tener complejidad O(1).
		\item[ID] debe tener complejidad O(|c|) donde c es la categor\'ia de la que se desea saber el id.
		\item[padres] debe tener complejidad O(|c|) donde c es la categor\'ia de la que se desea conocer sus padres.
	\end{itemize}

	\item \TipoVariable{itabCat}
	\begin{itemize}
		\item[hayMasPadres?] debe tener complejidad O(1).
		\item[subir] debe tener complejidad O(1).
		\item[actualID] debe tener complejidad O(1).
	\end{itemize}

	\item \TipoVariable{diccTrie($\alpha$)}
	\begin{itemize}
		\item[Definir] debe tener complejidad O(|k|) donde k es la clave.
	\end{itemize}

	\item \TipoVariable{Vector($\alpha$)}
	\begin{itemize}
		\item[Vacia] debe tener complejidad O(1).
		\item[AgregarAtras] debe tener complejidad O(n) s\'i y s\'olo s\'i se agregan $n$ elementos de forma consecutiva.
		\item[Longitud] debe tener complejidad O(1).
		\item[$\bullet\begin{bmatrix}\bullet\end{bmatrix}$] debe tener complejidad O(1).
	\end{itemize}

	\item \TipoVariable{Lista Enlazada ($\alpha$)}
	\begin{itemize}
		\item[Vacia] debe tener complejidad O(1).
		\item[AgregarAtras] debe tener complejidad O($copy$($\alpha$)), donde $\alpha$ es el tipo del elemento que va a ser colocado en la lista.
	\end{itemize}

	\item \TipoVariable{itLista($\alpha$)}
	\begin{itemize}
		\item[crearIt] debe tener complejidad O(1).
		\item[HaySiguiente?] debe tener complejidad O(1).
		\item[Avanzar] debe tener complejidad O(1).
		\item[Siguiente] debe tener complejidad O(1).
	\end{itemize}

	\item \TipoVariable{DiccTrie($\alpha$)}
	\begin{itemize}
		\item[Vacio] debe tener complejidad O(1).
		\item[Obtener] debe tener complejidad O(|$k$|) donde $k$ es la clave.
	\end{itemize}
\end{itemize}

\section{M\'odulo Iterador Unidireccional($\alpha$)}

\subsection{Interfaz}

	\textbf{par\'ametro formal}: \TipoVariable{$\alpha$}.

	\textbf{usa}: \TipoVariable{Bool, lista($\alpha$), itLista($\alpha$)}.

	\textbf{se explica con}: \TipoVariable{Iterador Unidireccional($\alpha$)}.

	\textbf{g\'eneros}: \TipoVariable{iteradorUni($\alpha$)}
	
	\modTitulo{Operaciones b\'asicas}

	\InterfazFuncion{crearIterador}{\In{l}{lista($\alpha$)}}{iteradorUni($\alpha$)}
	  {$res \igobs crearItUni(l)$}
	  [$\Theta(1)$]
	  [Crea un iterador unidireccional a la lista de forma tal que al pedir actual se obtenga el primer elemento de l.]

	\InterfazFuncion{HayMas?}{\In{it}{iteradorUni($\alpha$)}}{Bool}
	  {$res \igobs HayMas?(it)$}
	  [$\Theta(1)$]
	  [Devuelve true s\'i y s\'olo s\'i en el iterador todav\'ia quedan elementos por iterar.]

	\InterfazFuncion{Siguiente}{\Inout{it}{iteradorUni($\alpha$)}}{}
	  [$hayMas?(it) \land it \igobs it_0$]
	  {$it \igobs Avanzar(it_0)$}
	  [$\Theta(1)$]
	  [Avanza al iterador a la siguiente posici\'on.]
	  
	 \InterfazFuncion{Actual}{\In{it}{iteradorUni($\alpha$)}}{$\alpha$}
	  {$res \igobs Actual(it)$}
	  [$\Theta(1)$]
	  [Devuelve el elemento al que est\'a apuntando el iterador por referencia. Dicho elemento no debe ser modificado ya que alterar\'ia la lista y eso no est\'a permitido.]

\subsection{Representaci\'on}

	\begin{Estructura}{iteradorUni($\alpha$)}
		\begin{Tupla}
			\tupItem{it}{itLista($\alpha$)}
		\end{Tupla}
	\end{Estructura}
    
\tadAlinearAxiomas{Rep(e)}
\Rep[it][e]{true}\mbox{}

\begin{Justificacion}
\\Para representar el iterador unidireccional de la lista, decidimos usar el iterador bidireccional que nos provee la lista enlazada y obtener, del iterador, las operaciones que necesitamos.

\end{Justificacion}

\subsection{Algoritmos}

\begin{algorithm}[H]
\caption*{iCrearIterador(\In{l}{lista($\alpha$)}) $\DRef res$ : \TipoVariable{iteradorUni($\alpha$)}}
\begin{algorithmic}[1]
	\State $res.it \gets \Call{CrearIt}{l}$\Comment{$\Theta(1)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iHayMas?(\In{iterador}{iteradorUni($\alpha$)}) $\DRef res$ : \TipoVariable{Bool}}
\begin{algorithmic}[1]
	\State $res \gets \Call{HaySiguiente}{iterador.it}$\Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iSiguiente(\Inout{iterador}{iteradorUni($\alpha$)})}
\begin{algorithmic}[1]
	\State $\Call{Avanzar}{iterador.it}$\Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iActual(\In{iterador}{iteradorUni($\alpha$)}) $\DRef res$ : {$\alpha$}}
\begin{algorithmic}[1]
	\State $res \gets$ \Call{Siguiente}{$iterador.it$}\Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\subsection{Servicios Usados}

\textbf{Los siguientes m\'odulos deben cumplir los compromisos pedidos}

\begin{itemize}
	\item \TipoVariable{itLista($\alpha$)}
	\begin{itemize}
		\item[crearIt] debe tener complejidad O(1).
		\item[HaySiguiente?] debe tener complejidad O(1).
		\item[Avanzar] debe tener complejidad O(1).
		\item[Siguiente] debe tener complejidad O(1).
	\end{itemize} 
\end{itemize}

\end{document}