\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=3cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{ifthen}
\usepackage{libs/caratula}
\usepackage{libs/aed2-symb,libs/aed2-itef,libs/aed2-tad}
\usepackage{fixltx2e}
\usepackage{caption}
\usepackage{algpseudocode}
\usepackage[section]{algorithm}
\usepackage[colorlinks=false, linkcolor=blue]{hyperref}
\usepackage{calc}

%%--- Nuevos comandos START

\MakeRobust{\Call}
\algdef{SL}{var}{0}[2]{$#1$ \textbf{es} \TipoVariable{#2}}

\newcommand{\f}[1]{\text{#1}}
\renewcommand{\paratodo}[2]{$\forall~#2$: #1}

\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Justificacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Justificaci\'on de la elecci\'on de la estructura}%
  \vspace*{2ex}%
}{}

\newcommand{\modTitulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{
  \par\vspace*{2ex}
  \hypertarget{#1}{}
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}
  \par\vspace*{1ex}
}{
  \par\vspace*{2ex}
}

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

%%--- Nuevos comandos END

\sloppy

\parskip=5pt % 10pt es el tamaño de fuente

% Pongo en 0 la distancia extra entre itemes.
\let\olditemize\itemize
\def\itemize{\olditemize\itemsep=0pt}

% Acomodo fancyhdr.
\pagestyle{fancy}
\thispagestyle{fancy}
\addtolength{\headheight}{1pt}
\lhead{Algoritmos y Estructuras de Datos II}
\rhead{$2^{\mathrm{do}}$ cuatrimestre de 2012}
\cfoot{\thepage /\pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}

\author{Grupo 3 - Algoritmos y Estructuras de Datos II, 2do Cuatrimestre 2012.}
\date{}
\title{LinkLinkIt}

\begin{document}

\materia{Algoritmos y Estructuras de Datos II}
\submateria{Trabajo Pr\'actico de Dise\~no}
\titulo{LinkLinkIt}
\subtitulo{Cat\'alogo de rutas en internet}
\grupo{3}
\integrante{Barabas, Ariel}{775/11}{ariel.baras@gmail.com}
\integrante{Izcovich, Sabrina}{550/11}{sizcovich@gmail.com}
\integrante{Otero, Fernando}{424/11}{fergabot@gmail.com}
\integrante{Vita, Sebasti\'an}{149/11}{sebastian\_vita@yahoo.com.ar}

%Pagina de titulo e indice
\thispagestyle{empty}

\maketitle
\tableofcontents
\newpage

\section{M\'odulo DiccString($\alpha$)}
\subsection{Interfaz}

	\textbf{par\'ametro formal}: \TipoVariable{$\alpha$}.

	\textbf{usa}: \TipoVariable{Nat}, \TipoVariable{Bool}, \TipoVariable{String}, \TipoVariable{Puntero($\alpha$)},\TipoVariable{vector($\alpha$)}.

	\textbf{se explica con}: \TipoVariable{Diccionario(String, $\alpha$)}.

	\textbf{g\'eneros}: \TipoVariable{diccString($\alpha$)}.

	\modTitulo{Operaciones b\'asicas}

	\InterfazFuncion{Vacio}{}{diccString($\alpha$)}
	  {$res \igobs vacio$}
	  [$\Theta(1)$]
	  [Genera un diccionario vac\'io.]

	\InterfazFuncion{Definir}{\Inout{d}{diccString($\alpha$)}, \In{k}{string}, \In{s}{$\alpha$}}{}
	  [$d \igobs d_0$]
	  {$d \igobs definir(k, s, d_0)$}
	  [O(|$k$|)]
	  [En el caso en el que $k$ no pertenezca al diccionario, se lo agrega. Caso contrario, se reemplaza el significado anterior por $s$.]
	  [La clave se guarda por copia y el significado por referencia.]

	\InterfazFuncion{Definido?}{\In{d}{diccString($\alpha$)}, \In{k}{string}}{Bool}
	  {$res \igobs def?(k, d)$}
	  [O(|$k$|)]
	  [Devuelve \TipoVariable{True} s\'i y s\'olo s\'i $k$ es una clave del diccionario.]

	\InterfazFuncion{Obtener}{\Inout{d}{diccString($\alpha$)}, \In{k}{string}}{$\alpha$}
	  [$def?(k, d)$]
	  {$alias(res \igobs obtener(k, d))$}
	  [O(|$k$|)]
	  [Devuelve el significado por referencia de la clave $k$ en el diccString $d$.]

\subsection{Representaci\'on}

	\begin{Estructura}{diccString($\alpha$)}
	    \begin{Tupla}
	      \tupItem{trie}{puntero(nodo)}
	    \end{Tupla}

	    \begin{Tupla}[nodo]
	      \tupItem{hijo}{puntero(nodo)}
	      \tupItem{hermano}{puntero(nodo)}
	      \tupItem{elem}{puntero($\alpha$)}
	      \tupItem{letra}{char}
	    \end{Tupla}
	\end{Estructura}

\tadAlinearAxiomas{Rep(e)}
\Rep{$1 \land 2 \land 3$}\mbox{}

{\bf Donde:}

\begin{enumerate}
  \item Todos los nodos cuyo hijo sea NULL, tienen elem distinto de NULL.\\
        {\bf Formalmente:} $(\forall p:puntero(nodo))(p \in ePunteros(e.trie))) \impluego (((*p).hijo = NULL) \Rightarrow (*p).elem \neq NULL$)

  \item No existen dos \TipoVariable{punteros(nodo)} iguales.\\
        {\bf Formalmente:} $sinRepetidos(ePunteros(e.trie))$
        
% \item No existen dos hermanos con la misma letra\\
%        {\bf Formalmente:} $ (\forall p,q:puntero(nodo),\ p \in
%        ePunteros(e.trie),\ q \in Punteros(e.trie),\ (*q) = (*p).hermano)\\
%        (*q).letra \neq (*p).letra$

  \item No existen dos hermanos conteniendo la misma letra.\\
        {\bf Formalmente:} $(\forall p:puntero(nodo))p \in
        ePunteros(e.trie) \impluego sinRepetidos(letrasHermanos(p))$

\end{enumerate}
~
\tadAlinearAxiomas{ePunteros(p)}
\tadOperacion{ePunteros}{puntero(nodo)}{secu(puntero(nodo))}{}
\tadAxioma{ePunteros(p)}{\IF p = NULL THEN <> ELSE p $\bullet$ ePunteros((*p).hermano) \& ePunteros((*p).hijo) FI}
~
%\tadAlinearAxiomas{hermanos(p)}
%\tadOperacion{hermanos}{puntero(nodo)}{secu(puntero(nodo))}{}
%\tadAxioma{hermanos(p)}{\IF p = NULL THEN <> ELSE p $\bullet$
%hermanos((*p).hermano)) FI} 
~
\tadAlinearAxiomas{letrasHermanos(p)}
\tadOperacion{letrasHermanos}{puntero(nodo)}{secu(char)}{}
\tadAxioma{letrasHermanos(p)}{\IF p = NULL THEN <> ELSE p $\bullet$ 
letrasHermanos((*p).hermano) FI} 
~
\tadAlinearAxiomas{ePunteros(p)}
\tadOperacion{ePunteros}{puntero(nodo)}{secu(puntero(nodo))}{}
\tadAxioma{ePunteros(p)}{\IF p = NULL THEN <> ELSE p $\bullet$ ePunteros((*p).hermano) \& ePunteros((*p).hijo) FI}
~
\tadAlinearAxiomas{sinRepetidos(a)}
\tadOperacion{sinRepetidos}{secu($\alpha$)}{bool}{}
\tadAxioma{sinRepetidos(a)}{$\neg$esta?(prim(a),fin(a)) $\land$ sinRepetidos(fin(a))}
~
\tadAlinearAxiomas{Abs(e)}
\AbsFc{diccString($\alpha$)}{($\forall$ c:\ string)(def?(c, e)
$\Leftrightarrow$ ((e.trie $\not=$ NULL)) $\impluego$ (c $\in$
eClavesTrie(*(e.trie), c))) $\land$ ($\forall$ d:\ vector(char))def?(d, e)) \impluego
(obtener(d, e) $\Leftrightarrow$ dameSignif(d,e.trie))}
~
\tadAlinearAxiomas{eClavesTrie(n, pal)}
\tadOperacion{eClavesTrie}{nodo, string}{conj(string)}{}
\tadAxioma{eClavesTrie(n, pal)}{\IF n.elem = NULL THEN $\emptyset$ ELSE Ag(pal $\circ$ n.letra, $\emptyset$) FI $\cup$ \\
								 \IF n.hermano = NULL THEN $\emptyset$ ELSE eClavesTrie(*n.hermano, pal) FI $\cup$ \\
								 \IF n.hijo = NULL THEN $\emptyset$ ELSE eClavesTrie(*n.hijo, pal $\circ$ n.letra) FI}
~
En este auxiliar y en los auxiliares que llama, supongo que la clave existe.
\tadAlinearAxiomas{dameSignif(a, p)}
\tadOperacion{dameSignif}{vector(char), puntero(nodo)}{puntero($\alpha$)}{}
\tadAxioma{dameSignif(a, p)}{dameSignifAux(a, 0, p)}
~
\tadAlinearAxiomas{dameSignifAux(a, n, p)}
\tadOperacion{dameSignifAux}{vector(char), nat,
puntero(nodo)}{puntero($\alpha$)}{}
\tadAxioma{dameSignifAux(a, n, p)}{\IF n = long(a)-1 THEN (*p).elem
ELSE dameSignifAux(a, n+1, hijoChar(p, a[n])) FI}
~
\tadAlinearAxiomas{hijoChar(p, c)}
\tadOperacion{hijoChar}{puntero(nodo), char}{puntero(nodo)}{}
\tadAxioma{hijoChar(p, c)}{\IF (*p).letra = c THEN (*p).hijo ELSE
hijoChar((*p).hermano, c) FI}
~
%\tadAlinearAxiomas{hermanoChar(p, c)}
%\tadOperacion{hermanoChar}{puntero(nodo), char}{puntero(nodo)}{}
%\tadAxioma{hermanoChar(p, c)}{\IF (*p).letra = c THEN (*p).hermano
%ELSE hermanoChar((*p).hermano, c) FI}
%~
\modTitulo{Justificaci\'on de la elecci\'on de la estructura}
Para representar el DiccString, hemos elegido la estructura mostrada anteriormente (que representa a un trie) ya que nos permite acceder al contenido del mismo con la complejidad requerida para realizar los algoritmos de otros m\'odulos. Dicha estructura se explica de la siguiente manera:\\
\begin{itemize}
\item $trie$ es un puntero al primer char del primer string añadido.\\
\item $hijo$ y $hermano$ son punteros que nos sirven para poder recorrer el trie e ir formando los strings que se van almacenando en el trie. \\ \tab $hermano$ nos dice que esos dos caracteres(tanto el que se representa con el nodo que lo contiene como el nodo al que \'este apunta) comparten el mismo string como prefijo.\\
\tab $hijo$ nos dice que el string contin\'ua (en el caso en el que $hijo$ no es $NULL$) o que finaliza ah\'i (en el caso contrario).\\
\item $elem$ es un puntero al significado de la palabra, por lo que el $elem$ de un char puede o no ser NULL (dependiendo de si la palabra lleg\'o o no a su fin).\\
\item $letra$ es el char que representa ese nodo.\\
\end{itemize}



\modTitulo{Operacion Auxiliar}

	\InterfazFuncion{crearNodo}{\In {c}{char}}{nodo}
	  {$res.hijo \igobs \TipoVariable{NULL} \land res.hermano \igobs \TipoVariable{NULL} \land res.elem \igobs \TipoVariable{NULL} \land res.letra \igobs c$}
	  [$\Theta(1)$]
	  [Genera un nodo con todos los punteros a \TipoVariable{NULL} y con el char que se pasa como par\'ametro almacenado en $letra$.]

\subsection{Algoritmos}

\begin{algorithm}[H]
\caption*{iCrearNodo(\In{c}{char}) $\DRef res$ : \TipoVariable{nodo}}
\begin{algorithmic}[1]
	\State $res.elem \gets \TipoVariable{NULL}$ \Comment{$\Theta(1)$}
	\State $res.hijo \gets \TipoVariable{NULL}$ \Comment{$\Theta(1)$}
	\State $res.hermano \gets \TipoVariable{NULL}$ \Comment{$\Theta(1)$}
	\State $res.letra \gets c$ \Comment{$\Theta(1)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $4\Theta(1) = \Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iVacio() $\DRef res$ : \TipoVariable{diccString($\alpha$)}}
\begin{algorithmic}[1]
	\State $res.trie \gets \TipoVariable{NULL}$ \Comment{$\Theta(1)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iDefinir(\Inout{d}{diccString($\alpha$)}, \In {k}{string}, \In{s}{$\alpha$)}}
\begin{algorithmic}[1]
	\State $cargoTodo \gets d.trie = \TipoVariable{NULL}$\Comment{O(1)}
	\State $i \gets 0$\Comment{O(1)}
	\Statex
	\var{nodo}{nodo}
	\If {$cargoTodo$}
		\State $nodo \gets \Call{crearNodo}{k[i]}$ \Comment{O(1)}
		\State $i \gets i + 1$\Comment{O(1)}
	\Else
		\State $nodo \gets *d.trie$\Comment{O(1)}
	\EndIf
	\Statex	
	\Statex // Si al tomar el primer nodo, $cargoTodo$ es $true$, entonces en el bucle se crear\'an todos los nodos necesarios hasta formar $k$. En el caso contrario, se ir\'a recorriendo el \'arbol entero hasta encontrar el lugar donde colocar el resto de los caracteres de $k$ que no se encuentran en el \'arbol.	
	\Statex
	\While{$i < \Call{Longitud}{k}$}\Comment{$256 * O(|k|) * O(1) = O(|k|)$}
		\If{cargoTodo}
			\State $nodoVacio \gets \Call{crearNodo}{k[i]}$\Comment{O(1)}
			\State $nodo.hijo \gets \&nodoVacio$ \Comment{O(1)}
			\State $nodo \gets nodoVacio$ \Comment{O(1)}
			\State $i \gets i + 1$\Comment{O(1)}	
		\Else
					
			\If {$nodo.letra = k[i]$}\Comment{O(1)}
    			\If {$nodo.hijo = \TipoVariable{NULL}$}
					\State $cargoTodo \gets \TipoVariable{True}$\Comment{O(1)}
					\State $i \gets i + 1$\Comment{O(1)}
				\Else    			
    				\State $nodo \gets *nodo.hijo$\Comment{O(1)}
					\State $i \gets i + 1$\Comment{O(1)}	
    			\EndIf
			\Else
				\If{$nodo.hermano \neq \TipoVariable{NULL}$}
					\State $nodo \gets *nodo.hermano$\Comment{O(1)}
				\Else
					\State $nodoVacio \gets \Call{crearNodo}{k[i]}$\Comment{O(1)}
					\State $nodo.hermano \gets \&nodoVacio$ \Comment{O(1)}
					\State $nodo \gets nodoVacio$ \Comment{O(1)}
					\State $i \gets i + 1$\Comment{O(1)}
					\State $cargoTodo \gets \TipoVariable{True}$\Comment{O(1)}
				\EndIf
			\EndIf
		\EndIf
 	\EndWhile
	\Statex	
	\State $nodo.elem \gets \&s$ \Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $3O(1) + O(|k|) = O(|k|)$
\par \tab En el peor caso, que es en el que $cargoTodo$ es $false$ y la letra a buscar es la \'unica faltante en ese nivel, el bucle tiene 256 iteraciones y, al ser un valor constante, no altera la complejidad.
\end{algorithm}

\begin{algorithm}[H]
\caption*{iDefinido?(\In{d}{diccString($\alpha$)}, \In{k}{string} $\DRef res$ : \TipoVariable{Bool}}
\begin{algorithmic}[1]
	\var{nodo}{nodo}
	\State $i \gets 0$\Comment{O(1)}
	\Statex
	\If {d.trie = \TipoVariable{NULL}}
		\State $res \gets \TipoVariable{False}$\Comment{O(1)}
		\State $i \gets \Call{Longitud}{k}$\Comment{O(1)}
	\Else
		\State $nodo \gets *d.trie$\Comment{O(1)}
	\EndIf
	\Statex	
	\While{$i < \Call{Longitud}{k}$}\Comment{$256 * O(|k|) * O(1) = O(|k|)$}					
		\If {$nodo.letra = k[i]$}\Comment{O(1)}
    		\If {$i + 1 = \Call{Longitud}{k}$}\Comment{O(1)}
				\State $res \gets \TipoVariable{True}$\Comment{O(1)}
				\State $i \gets i + 1$\Comment{O(1)}
			\Else    			
				\If{$nodo.hijo = \TipoVariable{NULL}$}    			
   		 			\State $res \gets \TipoVariable{False}$\Comment{O(1)}
   		 			\State $i \gets \Call{Longitud}{k}$\Comment{O(1)}
   		 		\Else
   		 			\State $nodo \gets *nodo.hijo$\Comment{O(1)}
					\State $i \gets i + 1$\Comment{O(1)}
    			\EndIf
    		\EndIf
		\Else
			\If{$nodo.hermano \neq \TipoVariable{NULL}$} 
				\State $nodo \gets *nodo.hermano$\Comment{O(1)}
			\Else
				\State $res \gets \TipoVariable{False}$\Comment{O(1)}
				\State $i \gets \Call{Longitud}{k}$\Comment{O(1)}
			\EndIf
		\EndIf
 	\EndWhile
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $2O(1) + O(|k|) = O(|k|)$
\par \tab La complejidad del bucle se encuentra explicada en el algoritmo anterior.
\end{algorithm}

\begin{algorithm}[H]
\caption*{iObtener(\Inout{d}{diccString($\alpha$)}, \In{k}{string} $\DRef res$ : \TipoVariable{$\alpha$}}
\begin{algorithmic}[1]
	\State $nodo \gets *d.trie$\Comment{O(1)}
	\State $i \gets 0$\Comment{O(1)}
	\Statex
	\While{$i < \Call{Longitud}{k}$}\Comment{$256 * O(|k|) * O(1) = O(|k|)$}					
		\If {$nodo.letra = k[i]$}\Comment{O(1)}
    		\If {$i + 1 = \Call{Longitud}{k}$}\Comment{O(1)}
				\State $res \gets *nodo.elem$\Comment{O(1)}
			\Else    			
				\State $nodo \gets *nodo.hijo$\Comment{O(1)}	
    		\EndIf
			\State $i \gets i + 1$\Comment{O(1)}
		\Else
			\State $nodo \gets *nodo.hermano$\Comment{O(1)}
		\EndIf
 	\EndWhile
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $2O(1) + O(|k|) = O(|k|)$
\par \tab La complejidad del bucle se encuentra explicada en el algoritmo iDefinir.
\end{algorithm}
 
\subsection{Servicios Usados}

\textbf{Los siguientes m\'odulos deben cumplir con los compromisos pedidos}

\begin{itemize}
	\item \TipoVariable{Puntero($\alpha$)}
	\begin{itemize}
		\item[*] debe tener complejidad O(1).
		\item[\&] debe tener complejidad O(1).
	\end{itemize}

	\item \TipoVariable{Vector($\alpha$)}
	\begin{itemize}
		\item[Longitud] debe tener complejidad O(1).
		\item[$\bullet\begin{bmatrix}\bullet\end{bmatrix}$] debe tener complejidad O(1).
	\end{itemize}
\end{itemize}

\section{M\'odulo ArbolCategorias}
\subsection{Interfaz}

    \textbf{usa}: \TipoVariable{Nat}, \TipoVariable{String}, \TipoVariable{diccString($\alpha$)}, \TipoVariable{lista($\alpha$)}, \TipoVariable{iteradorUni($\alpha$)}, \TipoVariable{puntero($\alpha$)}.

	\textbf{se explica con}: \TipoVariable{ArbolCategorias}, \TipoVariable{Iterador Unidireccional($\alpha$)}, \TipoVariable{Vector($\alpha$)}.

	\textbf{g\'eneros}: \TipoVariable{abCat}, \TipoVariable{itAbCat}.

	\modTitulo{Operaciones b\'asicas}

	\InterfazFuncion{nuevoAC}{\In{raiz}{categoria}}{abCat}
	  [$\neg vacia?(raiz)$]
	  {$res \igobs nuevo(raiz)$}
	  [$\Theta(|raiz|)$]
	  [Crea un \'arbol con categor\'ia \emph{raiz}.]

	\InterfazFuncion{raiz}{\In{ac}{abCat}}{categoria}
	  {$res \igobs raiz(ac)$}
	  [$\Theta(1)$]
	  [Devuelve el nombre de la categor\'ia raiz por referencia, con lo cual, si \'este valor es modificado, se romper\'a el invariante de representaci\'on invalidando todo el \'arbol.]

	\InterfazFuncion{agregar}{\Inout{ac}{abCat}, \In{padre}{categoria}, \In{hija}{categoria}}{}
	  [$ac \igobs ac_0 \land \emph{est\'a}?(padre, ac) \land \neg\emph{vac\'ia}?(hija) \land \neg\emph{est\'a}?(hija, ac)$]
	  {$ac \igobs agregar(ac_0, padre, hija)$}
	  [$\Theta(|padre| + |hija|)$]
	  [Agrega la categor\'ia $hija$ a $padre$.]

	\InterfazFuncion{hijas}{\In{ac}{abCat}, \In{padre}{categoria}}{iteradorUni(categoria)}
	  [$\emph{est\'a}?(padre, ac)$]
	  {$res \igobs crearItUni(conjuntoASecuencia(hijos(ac, padre)))$}
	  [$\Theta(|padre|)$]
	  [Devuelve un iterador que proyecta las hijas del padre de forma tal que, al pedir actual, el iterador devuelve el primer elemento de la lista.]
	  [El iterador se invalida s\'i y s\'olo s\'i se elimina el elemento siguiente del iterador.]

    \InterfazFuncion{padres}{\In{ac}{abCat}, \In{hija}{categoria}}{itAbCat}
      [$\emph{est\'a}?(hija, ac)$]
	  {$res \igobs CrearItUni(padres(ac, hija))$}
	  [$\Theta(|hija|)$]
	  [Devuelve un iterador que proyecta los IDs de los padres de forma tal que, al pedir ActualID, el iterador devuelve el id de la hija.]

	\InterfazFuncion{ID}{\In{ac}{abCat}, \In{c}{categoria}}{Nat}
	  [$\emph{est\'a}?(c, ac)$]
	  {$res \igobs id(ac, c)$}
	  [$\Theta(|c|)$]
	  [Devuelve el id de la categor\'ia dada.]

	\InterfazFuncion{cantCategorias}{\In{ac}{abCat}}{Nat}
	  {$res \igobs \#categorias(ac)$}
	  [$\Theta(1)$]
	  [Devuelve la cantidad de categor\'ias existentes en el \'arbol.]


\modTitulo{Funciones auxiliares}

	\tadOperacion{conjuntoASecuencia}{Conjunto($\alpha$)}{Secuencia($\alpha$)}{}
	\tadAlinearAxiomas{conjuntoASecuencia($c$)}
    \tadAxioma{conjuntoASecuencia($c$)}{\IF $\emptyset$?($c$) THEN <> ELSE dameUno($c$) $\bullet$ conjuntoASecuencia(sinUno($c$)) FI}
~
    \tadOperacion{padres}{acat\ $ac$, categoria\ $hija$}{Secuencia(Nat)}{est\'a?($hija$, $ac$)}
    %\tadAlinearAxiomas{padres($ac$, $hija$)}
	\tadAxioma{padres($ac$, $hija$)}{\IF $hija$ \igobs raiz($ac$) THEN 1 $\bullet$ <> ELSE id($ac$, $hija$) $\bullet$ padres($ac$, padre($ac$, $hija$)) FI}

\modTitulo{Operaciones del iterador}

   	\InterfazFuncion{HayMasPadres?}{\In{it}{itAbCat}}{Bool}
	  {$res \igobs HayMas?(it)$}
	  [$\Theta(1)$]
	  [Devuelve \TipoVariable{True} s\'i y s\'olo s\'i en el iterador todav\'ia quedan elementos por iterar.]

	\InterfazFuncion{Subir}{\Inout{it}{itAbCat}}{}
	  [$it \igobs it_0 \land hayMas?(it)$]
	  {$it \igobs Avanzar(it_0)$}
	  [$\Theta(1)$]
	  [Avanza el iterador a la siguiente posici\'on.]
	  
	 \InterfazFuncion{ActualID}{\In{it}{itAbCat}}{Nat}
	  {$res \igobs Actual(it)$}
	  [$\Theta(1)$]
	  [Devuelve el id del elemento al que est\'a apuntando.]
	
\subsection{Representaci\'on}

	\begin{Estructura}{abCat}
	    \begin{Tupla}
	      \tupItem{categorias}{diccString(catInfo)}
	      \tupItem{raiz}{categoria}
	      \tupItem{ultID}{Nat}
	    \end{Tupla}

	    \begin{Tupla}[catInfo]
	      \tupItem{id}{Nat}
	      \tupItem{padre}{puntero(catInfo)}
	      \tupItem{hijas}{lista(categoria)}
	    \end{Tupla}
	\end{Estructura}

\tadAlinearAxiomas{Rep(e)}
\Rep[estr][e]{$1 \land 2 \land 3 \yluego 4 \yluego 5 \land 6 \land 7 \yluego 8 \land 9 \yluego 10 \land 11$}\mbox{}

{\bf Donde:}

ACLARACI\'ON: Llamaremos a la operaci\'on ``esta?'' (definida en el TAD secuencia) como ``estaLista?'' para no generar confusiones.\\ 
\begin{enumerate}
  \item El id de la ra\'iz del \'arbol es 1 (requerido por el enunciado del TP).\\
        {\bf Formalmente:} $id(e.raiz) =_{obs} 1$
        

  \item No existe ninguna categor\'ia incluida en sus categor\'ias hijas.\\
        {\bf Formalmente:} $(\forall c:categoria)esta?(c,claves(e.categorias)) \impluego \neg(estaLista?(c,eHijas(c)))$

  \item Todas las categor\'ias tienen padre, excluyendo la ra\'iz.\\
        {\bf Formalmente:} $(\forall c:categoria)(esta?(c,claves(e.categorias)) \land (c\not=e.raiz)) \impluego ((\exists t:categoria)(esta?(t,claves(e.categorias)) \land t\not=c) \yluego estaLista?(c,eHijas(t)))$

  \item Existe una categor\'ia que no tiene padre y que es igual a ra\'iz.\\
        {\bf Formalmente:} $(\exists c:categoria)(esta?(c,claves(e.categorias)) \yluego c=_{obs}e.raiz) \impluego (e.raiz.padre) = Null$
  	     
  \item Ninguna categor\'ia tiene m\'as de un padre.\\
        {\bf Formalmente:} $\neg(\exists t,c:categoria)((esta?(c,claves(e.categorias))) \yluego (esta?(t,claves(e.categorias)))$ $\yluego (t\not=c) \land (t\not=e.raiz)) \yluego ((\forall k:categoria)esta?(k,claves(e.categorias)) \impluego (estaLista?(k,eHijas(c)) \yluego estaLista?(k,eHijas(t)))$
  
  \item La cantidad de categor\'ias totales es igual a UltId.\\
        {\bf Formalmente:} $\#claves(e.categorias) =_{obs} e.ultId$
  
  
  \item No existen dos IDs iguales para categor\'ias distintas.\\
        {\bf Formalmente:} $(\forall c,t:categoria)(esta?(c,claves(e.categorias)) \land esta?(t,claves(e.categorias)) \land t\not=c) \impluego id(c)\not=id(t)$
        
  \item Las categor\'ias hijas de cada categor\'ia tienen un id mayor a \'esta.\\
        {\bf Formalmente:} $((\forall c:categoria)esta?(c,claves(e.categorias))) \impluego ((\forall t:categoria)(esta?(c,claves(e.categorias)) \yluego estaLista?(t,eHijas(c))) \impluego id(c)<id(t))$
              
  \item Ningún padre es Null salvo el de la raíz. \\
  		{\bf Formalmente:} $(\forall t:categoria)(esta?(t,claves(e.categorias)) \land (t\not=e.raiz)) \impluego ePadre(e,t)\not=Null$
  		
  \item El padre de la raíz es Null.\\
  {\bf Formalmente:} $ePadre(e, e.raiz) =_{obs} Null$
  
  \item La altura del \'arbol est\'a acotada por un natural. Esta propiedad nos asegurar\'a que el \'arbol no sea c\'iclico.\\
  {\bf Formalmente:} $(\exists n:nat)acotado(e, e.raiz, n)$
    
\end{enumerate}

\tadAlinearAxiomas{acotado(a, cat, n)}
\tadOperacion{acotado}{estr, categoria, Nat}{Bool}{}
\tadAxioma{acotado(a, cat, n)}{\IF $n = 0$ THEN \TipoVariable{False} ELSE ($\forall$ h:categoria)(h $\in$ eHijas(a, cat))acotado(n-1, a, h) FI}
~
\tadAlinearFunciones{ePadre}{estr\ e, categoria\ c}
\tadAlinearAxiomas{ePadre(e, c)}
\tadOperacion{eHijas}{estr\ e, categoria\ c}{secu(categoria)}{def?(c, e.categorias)}
\tadAxioma{eHijas(e, c)}{obtener(e.categorias, c).hijas}
~
\tadOperacion{ePadre}{estr\ e, categoria\ c}{puntero(catInfo)}{def?(c, e.categorias)}
\tadAxioma{ePadre(e, c)}{obtener(e.categorias, c).padre}
~
\tadAlinearFunciones{Abs}{estr\ e}
\tadAlinearAxiomas{Abs(e)}
\AbsFc{acat}{a:acat $|$ e.raiz = raiz(a) $\land$ ($\forall$ c:categoria)esta?(c,claves(e.categorias)) $\impluego$ eId(e,c) = id(a,c) $\land$ (($\forall$ c:categoria)esta?(c,claves(e.categorias)) $\impluego$ (($\exists$ t: categoria)esta?(c,claves(e.categorias)) $\impluego$ esSuId?(t,(ePadre(e,c).id)) $\yluego$ padre(a,c) = t) $\yluego$ categorias(a) = claves(e.categorias)}
~
\tadAlinearFunciones{eId}{estr\ e, categoria\ c}
\tadAlinearAxiomas{eId(e, c)}
\tadOperacion{eId}{estr\ e, categoria\ c}{Nat}{def?(c, e.categorias)}
\tadAxioma{eId(e, c)}{obtener(e.categorias, c).id}
~
\tadAlinearFunciones{esSuId?}{estr\ e, categoria\ c, nat\ i}{}
\tadAlinearAxiomas{esSuId?(e, i)}
\tadOperacion{esSuId?}{estr\ e, categoria\ c, Nat\ i}{Bool}{def?(c, e.categorias) $\land$ i <= e.ultId}
\tadAxioma{esSuId?(e, i)}{obtener(e.categorias, c).id = i}

\modTitulo{Justificaci\'on de la representacion de la estructura}
Para representar el \'arbol de categor\'ias elegimos esta estructura por los siguientes motivos:
\begin{itemize}
	\item El Diccionario String modulariza perfectamente un \'arbol de categor\'ias dado que es posible conocer los hijos de cada una de las categor\'ias con la complejidad requerida, para esto, se coloc\'o en cada nodo una lista con los nombres de cada hijo. \\
	\item Esta estructura nos permite acceder a la ra\'iz del arbol en O(1) y al ID de cada categor\'ia en O(|$c$|) donde $c$ es el nombre de la categor\'ia.\\
	\item Tener un puntero a la categor\'ia padre nos permite luego hacer un iterador de padres el cual utilizaremos en linkLinkIt.\\
\end{itemize}

La estructura elegida se puede explicar de la siguiente manera:
\begin{itemize}
	\item $categorias$ es un DiccString que almacena cada categor\'ia junto con su informaci\'on. \\
	\item $raiz$ es la categor\'ia raiz del arbol de categorias.\\
	\item $ultId$ es el $id$ de la \'ultima categor\'ia agregada al arbol.\\
	\item $id$ es el id de la categor\'ia cuya $catInfo$ est\'a siendo observada.\\
	\item $padre$ es un puntero a la informaci\'on del padre de la categor\'ia que est\'a siendo observada.\\
	\item $hijas$ es la lista de las hijas directas de un categor\'ia.\\
\end{itemize}

\subsection{Iterador}

	\begin{Estructura}{itAbCat}
	    \begin{Tupla}
	      \tupItem{iterador}{puntero(catInfo)}
	    \end{Tupla}
	\end{Estructura}

\tadAlinearFunciones{Rep}{estr\ e}
\tadAlinearAxiomas{Rep(e)}
\Rep{e.iterador $\neq$ NULL}\mbox{}

\AbsFc{itAbCat}{it:itAbCat $|$ Siguientes(it) \igobs ePadres(e.iterador)}
~
\tadAlinearFunciones{ePadres}{puntero(catInfo)}
\tadAlinearAxiomas{ePadres(pci)}
\tadOperacion{ePadres}{puntero(catInfo)}{secu(Nat)}{}
\tadAxioma{ePadres(pci)}{\IF pci = NULL THEN <> ELSE (*pci).id $\bullet$ ePadres((*pci).padre) FI}
~
\modTitulo{Justificaci\'on de la elecci\'on de la estructura}
\par El iterador necesita, \'unicamente, guardar un puntero a la categor\'ia actual ya que con esto alcanza para acceder al padre y, de esta manera, subir en O(1). \'Este se usar\'a en el LinkLinkIt.


\subsection{Algoritmos}

\begin{algorithm}[H]
\caption*{iNuevoAC(\In{raiz}{categoria}) $\DRef res$ : \TipoVariable{abCat}}
\begin{algorithmic}[1]
	\State $res.categorias \gets$ \Call{Vacio}{\null}\Comment{O(1)}
	\State $res.raiz \gets raiz$\Comment{O(|$raiz$|)}
	\State $res.ultID \gets 1$\Comment{O(1)}
	\Statex
	\var{infoRaiz}{catInfo}
	\State $infoRaiz.id \gets res.ultID$\Comment{O(1)}
	\State $infoRaiz.padre \gets \TipoVariable{NULL}$\Comment{O(1)}
	\State $infoRaiz.hijas \gets$ \Call{Vacia}{\null}\Comment{O(1)}
	\State \Call{Definir}{$res.categorias, raiz, infoRaiz$}\Comment{O(|$raiz$|)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $5O(1) + 2O(|raiz|) = O(|raiz|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iRaiz(\In{ac}{abCat}) $\DRef res$ : \TipoVariable{categoria}}
\begin{algorithmic}[1]
	\State $res \gets ac.raiz$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iAgregar(\Inout{ac}{abCat}, \In{padre}{categoria}, \In{hija}{categoria})}
\begin{algorithmic}[1]
	\State $ac.ultID \gets ac.ultID + 1$\Comment{O(1)}
	\State $infoPadre \gets$ \Call{Obtener}{$ac.categorias, padre$}\Comment{O(|$padre$|)}
	\Statex
	\var{infoHija}{catInfo}
	\State $infoHija.id \gets ac.ultID$\Comment{O(1)}
	\State $infoHija.padre \gets \&infoPadre$\Comment{O(1)}
	\State $infoHija.hijas \gets$ \Call{Vacia}{\null}\Comment{O(1)}
	\State \Call{Definir}{$ac.categorias, hija, infoHija$}\Comment{O(|$hija$|)}
	\Statex
	\State \Call{AgregarAtras}{$infoPadre.hijas, hija$}\Comment{O(|$hija$|)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $4O(1) + 2O(|hija|) + O(|padre|) = O(|hija|) + O(|padre|) = O(|hija| + |padre|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iHijas(\In{ac}{abCat}, \In{padre}{categoria}) $\DRef res$ : \TipoVariable{iteradorUni(categoria)}}
\begin{algorithmic}[1]
    \State $nodoHijo \gets \Call{Obtener}{ac.categorias, padre}$\Comment{O(|$padre$|)}
	\State $res \gets \Call{crearIterador}{nodoHijo.hijas}$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|padre|) + O(1) = O(|padre|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iPadres(\In{ac}{abCat}, \In{hija}{categoria}) $\DRef res$ : \TipoVariable{itAbCat}}
\begin{algorithmic}[1]
    \State $nodoHija \gets \Call{Obtener}{ac.categorias, hija}$\Comment{O(|$hija$|)}
    \State $iterador \gets \&nodoHija$\Comment{O(1)}
    \State $res \gets iterador$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|hija|) + 2O(1) = O(|hija|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iID(\In{ac}{abCat}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $catInfo \gets$ \Call{Obtener}{$ac.categorias, c$}\Comment{O(|$c$|)}
	\State $res \gets catInfo.id$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|c|) + O(1) = O(|c|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iCantCategorias(\In{ac}{abCat}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $res \gets ac.ultId$\Comment{$O(1)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\subsubsection{Algoritmos del Iterador}

\begin{algorithm}[H]
\caption*{iHayMasPadres?(\In{it}{itAbCat}) $\DRef res$ : \TipoVariable{Bool}}
\begin{algorithmic}[1]
	\State $res \gets (*it.iterador).padre \neq \TipoVariable{NULL}$\Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iSubir(\Inout{it}{itAbCat})}
\begin{algorithmic}[1]
	\State $it \gets (*it.iterador).padre$ \Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iActualID(\In{it}{itAbCat}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $res \gets (*it.iterador).id$ \Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\subsection{Servicios Usados}

\textbf{Los siguientes m\'odulos deben cumplir con los compromisos pedidos a continuaci\'on:}

\begin{itemize}
	\item \TipoVariable{Lista Enlazada ($\alpha$)}
	\begin{itemize}
		\item[Vacia] debe tener complejidad O(1).
		\item[AgregarAtras] debe tener complejidad O($copy$($a$)), donde $a$ es el tipo del elemento que se va a colocar en la lista.
	\end{itemize}

	\item \TipoVariable{Iterador Unidireccional ($\alpha$)}
	\begin{itemize}
		\item[crearIterador] debe tener complejidad O(1).
	\end{itemize}

	\item \TipoVariable{diccString($\alpha$)}
	\begin{itemize}
		\item[Vacio] debe tener complejidad O(1).
		\item[Definir] debe tener complejidad O(|$k$|) donde $k$ es el string que se va a colocar por definici\'on.
		\item[Obtener] debe tener complejidad O(|$k$|) donde $k$ es la clave.
	\end{itemize}

	\item \TipoVariable{Puntero($\alpha$)}
	\begin{itemize}
		\item[\&] debe tener complejidad O(1).
		\item[*] debe tener complejidad O(1).
	\end{itemize}
\end{itemize}

\section{M\'odulo LinkLinkIt}

\subsection{Interfaz}
	
	\textbf{usa}: \TipoVariable{Nat}, \TipoVariable{Bool}, \TipoVariable{String}, \TipoVariable{Puntero($\alpha$)}, \TipoVariable{abCat}, \TipoVariable{itAbCat}, \TipoVariable{diccString($\alpha$)}, \TipoVariable{vector($\alpha$)}, \TipoVariable{lista($\alpha$)}, \TipoVariable{itLista($\alpha$)}.

	\textbf{se explica con}: \TipoVariable{linkLinkIt, ArbolCategorias, Iterador Unidireccional, tupla}.

	\textbf{g\'eneros}: \TipoVariable{LinkLinkIt}.

	\modTitulo{Operaciones b\'asicas}
	
	\InterfazFuncion{crearLinkLinkIt}{\In{ac}{abCat}}{LinkLinkIt}
	  {$res \igobs iniciar(ac)$}
	  [$\Theta(\#categorias(ac))$]
	  [Crea un sistema LinkLinkIt. El \'arbol de categor\'ias se guarda por refencia.]

	\InterfazFuncion{agregarLink}{\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{c}{categoria}}{}
	  [$s \igobs s_0$ $\land$ $l \notin links(s)$ $\land$ \emph{est\'a}?$(c, categorias(s))$]
	  {$s \igobs nuevoLink(s_0, l, c)$}
	  [$O(|l| + |c| + h)$]
	  [Agrega un link a la categor\'ia se\~{n}alada.]

	\InterfazFuncion{accederLink}{\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{f}{fecha}}{}
	  [$s \igobs s_0$ $\land$ $l \in$ links($s$) $\land$ $f \geq$ fechaActual($s$)]
	  {$s \igobs acceso(s_0, l, f)$}
	  [$O(|l|)$]
	  [Registra un acceso al link provisto.]

	\InterfazFuncion{cantLinks}{\In{s}{LinkLinkIt}, \In{c}{categoria}}{Nat}
	  [\emph{est\'a}?(c, categorias(s))]
	  {$res \igobs cantLinks(s, c)$}
	  [$O(|c|)$]
	  [Devuelve la cantidad de links que tiene una categor\'ia y sus hijas.]

    \InterfazFuncion{linksOrdenadosPorAccesos}{\Inout{s}{LinkLinkIt}, \In{c}{categoria}}{itLinks}
	  [$\emph{est\'a}?(c, categorias(s))$]
	  {$res \igobs CrearItUni(secuInfoLinks(s, c))$}
	  [$O(|c| + n^2)$]
	  [Devuelve la cantidad de links que tiene una categor\'ia.]

\modTitulo{Funciones auxiliares}

\tadAlinearFunciones{secuInfoLinks}{lli\ s, categoria\ c, secu(link)\ ls}
\tadAlinearAxiomas{secuInfoLinks(s, c)}

\tadOperacion{secuInfoLinks}{lli\ s, categoria\ c}{secu(tupla(link, categoria, Nat))}{est\'a?(c, categorias(s))}
\tadAxioma{secuInfoLinks(s, c)}{infoLinks(s, c, linksOrdenadosPorAccesos(s, c))}
~
\tadOperacion{infoLinks}{lli\ s, categoria\ c, secu(link)\ ls}{secu(tupla(link, categoria, Nat))}{est\'a?(c, categorias(s)) $\land$ ($\forall$ l:link)(est\'a?(l, ls) $\Rightarrow$ l $\in$ links(s) $\land$ esSubCategoria(categorias(s), c, categoriaLink(s, l)))}
\tadAlinearAxiomas{infoLinks(s, c, ls)}
\tadAxioma{infoLinks(s, c, ls)}{\IF Vacia(ls) THEN <> ELSE
				tupla(prim(ls), categoriaLink(s, prim(ls)), accesosRecientes(s, c, prim(ls))) $\bullet$ infoLinks(s, c, fin(ls))
			FI}

\modTitulo{Operaciones del iterador}

	\InterfazFuncion{CrearItLinks}{\In{ls}{lista(infoLink), \In{f}{fecha}}, \In{s}{LinkLinkIt}, \In{c}{categoria}}{itLinks}
	  [$(\forall\ l:infoLink)(\emph{est\'a}?(l, ls) \Rightarrow l.ultAcceso \leq f)$]
	  {$res \igobs CrearItUni(secuInfoLinks(s, c))$}
	  [$O(1)$]
	  [Genera un iterador de links que permite verse a si mismo, observar su categor\'ia y la cantidad de accesos recientes.]

	\InterfazFuncion{SiguienteLink}{\In{it}{itLinks}}{link}
	  [$HayMas?(it)$]
	  {$res \igobs \Pi_1(Actual(it))$}
	  [$O(1)$]
	  [Devuelve el siguiente link.]

	\InterfazFuncion{SiguienteCategoria}{\In{it}{itLinks}}{categoria}
	  [$HayMas?(it)$]
	  {$res \igobs \Pi_2(Actual(it))$}
	  [$O(1)$]
	  [Devuelve la categor\'ia del siguiente link.]

	\InterfazFuncion{SiguienteAccesosRecientes}{\In{it}{itLinks}}{Nat}
	  [$HayMas?(it)$]
	  {$res \igobs \Pi_3(Actual(it))$}
	  [$O(1)$]
	  [Devuelve los accesos recientes del siguiente link.]

	\InterfazFuncion{HaySiguiente}{\In{it}{itLinks}}{Bool}
	  {$res \igobs HayMas?(it)$}
	  [$O(1)$]
	  [Informa si hay un link siguiente.]

	\InterfazFuncion{Avanzar}{\Inout{it}{itLinks}}{}
	  [$it = it_0 \land HayMas?(it)$]
	  {$it \igobs Avanzar(it_0)$}
	  [$O(1)$]
	  [Avanza al siguiente link.]

\subsection{Representaci\'on}

\begin{Estructura}{LinkLinkIt}
    \begin{Tupla}
      \tupItem{aCategorias}{abCat}
      \tupItem{\\ linksPorCat}{vector(lista(puntero(infoLink)))}
      \tupItem{\\ infoLinks}{diccString(infoLink)}
    \end{Tupla}

	\begin{Tupla}[infoLink]
		\tupItem{link}{link}
		\tupItem{categoria}{categoria}
    	\tupItem{ultAcceso}{fecha}
		\tupItem{accesos}{vector(Nat)}
	\end{Tupla}
\end{Estructura}

\tadAlinearFunciones{Rep}{estr}
\tadAlinearAxiomas{Rep(e)}
\Rep{$1 \land 2$}\mbox{}

{\bf Donde:}

\begin{enumerate}
  \item La longitud de linksPorCat es igual a la cantidad de categor\'ias existentes.\\
		{\bf Formalmente:} $\#e.linksPorCat \igobs \#categorias(e.aCategorias)$

  \item Todo infoLink en linksPorCat debe estar definido en infoLinks con la clave igual a su link.\\
		{\bf Formalmente:} $(\forall pil:puntero(infoLink))(pil \in aplanar(e.linksPorCat) \impluego (pil \neq NULL \yluego \&obtener(e.infoLinks, (*pil).link) \igobs pil))$

  \item El vector accesos de todo infoLink tiene longitud 3.\\
		{\bf Formalmente:} 

  \item Todo infoLink definido en infoLinks aparece en la lista que le corresponde seg\'un el ID de su categor\'ia y las categor\'ias padres a ella.\\
		{\bf Formalmente:}
\end{enumerate}

\tadAlinearFunciones{aplanar}{secu(secu($\alpha$))}
\tadAlinearAxiomas{aplanar(ss)}
\tadOperacion{aplanar}{secu(secu($\alpha$))}{secu($\alpha$)}{}
\tadAxioma{aplanar(ss)}{\IF vacia?(ss) THEN <> ELSE prim(ss) $\bullet$ fin(ss) FI}
~
\tadAlinearFunciones{Abs}{estr\ e}
\tadAlinearAxiomas{Abs(e)}
\AbsFc{lli}{}

\modTitulo{Justificaci\'on de la elecci\'on de la estructura}
Para representar al sistema LinkLinkIt elegimos esta representaci\'on ya que relaciona los m\'odulos necesarios para definirla respetando las complejidades requeridas. Dicha representaci\'on se explica de la siguiente manera:

\begin{itemize}
  \item en estr
  \begin{itemize}
	\item $aCategorias$ es el \'arbol de categor\'ias del sistema.
	\item $linksPorCat$ es un vector en donde cada uno de sus \'indices representa el ID de la categor\'ia a la que su lista de links pertenecen. No solo tienen sus links, sino tambi\'en los links de sus hijos. Cuando me refiero a link, nos estamos refiriendo en verdad a un \TipoVariable{puntero(InfoLink)}.
	\item $infoLinks$ es un DiccString que guarda, para cada link, sus datos representados por un $infoLink$.
  \end{itemize}
  \item en infoLink
  \begin{itemize}
	\item $link$ es el link del que queremos observar la informaci\'on.
	\item $categoria$ es la categor\'ia del link que estamos observando.
	\item $ultAcceso$ es la fecha de la \'ultima visita realizada a ese link.
	\item $accesos$ es un vector de 3 posiciones en el que se guarda la cantidad de visitas de los 3 \'ultimos d\'ias (respectivamente) para el link observado.
  \end{itemize}
\end{itemize}

\subsection{Iterador}

\begin{Estructura}{itLinks}
	\begin{Tupla}
		\tupItem{it}{itLista(puntero(infoLink))}
		\tupItem{ultAcceso}{fecha}
		\tupItem{s}{LinkLinkIt}
	\end{Tupla}
\end{Estructura}

\tadAlinearFunciones{Rep}{estr}
\tadAlinearAxiomas{Rep(e)}
\Rep{$(\forall p:puntero(infoLink)) (p \in Siguientes(e.it) \impluego (1 \yluego (2 \land 3)))$}\mbox{}

{\bf Donde:}

\begin{enumerate}
  \item Ning\'un puntero puede ser NULL.\\
		{\bf Formalmente:} $p \neq NULL$

  \item ultAcceso debe representar el mayor \'ultimo acceso de todos los links.\\
		{\bf Formalmente:} $(*p).ultAcceso \leq e.ultAcceso$

  \item Todos los infoLinks existen en el sistema.\\
		{\bf Formalmente:} $def?(e.s.infoLinks, (*p).link) \yluego \&obtener(e.s.infoLinks, (*p).link) \igobs p$
\end{enumerate}

~
\tadAlinearFunciones{Abs}{estr\ e}
\tadAlinearAxiomas{Abs(e)}
\AbsFc{itL}{}

\modTitulo{Justificaci\'on de la elecci\'on de la estructura}

Esta estructura contiene una lista de links para los cuales (en orden) se puede saber qu\'e link es, su categor\'ia y su ``accesosRecientes''. Para este \'ultimo dato es que necesitamos tener una copia del sistema y saber la \'ultima fecha a la cual fue accedido alguno de estos links, que guardamos en $utlAcceso$ para poder accederla r\'apidamente.

\modTitulo{Operacion Auxiliar}

\InterfazFuncion{puntajeDelLink}{\In{s}{LinkLinkIt}, \In{il}{infoLink}, \In{f}{fecha}}{Nat}
  [$il.ultAcceso \leq f$]
  {$res \igobs accesosRecientes(s, il.categoria, il.link)$}
  [$\Theta(1)$]
  [Devuelve el puntaje del link. Esta funci\'on es privada ya que recibe una estructura interna.]

\subsection{Algoritmos}

\begin{algorithm}[H]
\caption*{iCrearLinkLinkIt(\In{ac}{abCat}) $\DRef res$ : \TipoVariable{\hyperlink{LinkLinkIt}{LinkLinkIt}}}
\begin{algorithmic}[1]
	\State $res.aCategorias \gets ac$\Comment{$\Theta$(1)}
	\State $res.linksPorCat \gets \Call{Vacia}{\null}$\Comment{$\Theta$(1)}
	\State $res.infoLinks \gets \Call{Vacio}{\null}$\Comment{$\Theta$(1)}
	\Statex
	\For {$i = 1 \to \Call{cantCategorias}{ac}$} \Comment{$O(1) + \#categorias(ac) * \Theta(1) = \Theta(\#categorias(ac))$}
	\State $\Call{AgregarAtras}{res.linksPorCat, \Call{Vacia}{\null}}$\Comment{$\Theta(1)$}
	\EndFor
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $3\Theta(1) + \Theta(\#categorias(ac)) = \Theta(\#categorias(ac))$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iAgregarLink(\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{c}{categoria})}
\begin{algorithmic}[1]
	\State $categoriaID \gets \Call{ID}{s.aCategorias, c}$\Comment{O(|c|)}
	\Statex
	\var{info}{infoLink}
	\State $info.link \gets l$\Comment{O(|l|)}
	\State $info.categoria \gets c$\Comment{O(|c|)}
    \State $info.ultAcceso \gets 0$\Comment{O(1)}
    \For{$i = 1 \to 3$}\Comment{3O(1) = O(1)}
        \State $\Call{AgregarAtras}{info.accesos, 0}$\Comment{O(1)}
    \EndFor
	\State $\Call{Definir}{s.infoLinks, l, info}$\Comment{O(|$l$|)}
    \State $\Call{AgregarAtras}{s.linksPorCat[categoriaID-1], \&info}$\Comment{$O(1)$}
	\Statex
	\State $it \gets \Call{padres}{s.aCategorias, c}$\Comment{O(|c|)}
	\While{$\Call{HayMasPadres?}{it}$}\Comment{$(O(h) + O(1)) * 3O(1) = O(h)$}
    	\State $\Call{Subir}{it}$\Comment{O(1)}
    	\State $categoriaID \gets \Call{ActualID}{s, categoriaID}$\Comment{$O(1)$}
		\State $\Call{AgregarAtras}{s.linksPorCat[categoriaID-1], \&info}$\Comment{$O(1)$}
	\EndWhile
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1) + 3O(|c|) + 2O(|l|) + O(h) = O(|c|) + O(|l|) + O(h) = O(|c| + |l| + h)$
\par \tab El bucle tiene $h$ iteraciones ya que inicia en un nodo y luego, en cada ciclo, se va subiendo hasta la raiz del \'arbol.
\end{algorithm}

\begin{algorithm}[H]
\caption*{iAccederLink(\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{f}{fecha})}
\begin{algorithmic}[1]
	\State $link \gets \Call{Obtener}{s.infoLinks, l}$\Comment{$O(|l|)$}
    \State $diff \gets f - link.ultAcceso$\Comment{$O(1)$}
    \Statex
    \Statex // Muevo hacia atr\'as los d\'ias que pasaron
    \State $i \gets 0$\Comment{$O(1)$}
    \While{$i < 3 - diff$}\Comment{$3 * 2O(1) = O(1)$}
        \State $link.accesos[i] \gets link.accesos[i + diff]$\Comment{$2O(1) = O(1)$}
        \State $i \gets i + 1$\Comment{$O(1)$}
    \EndWhile
    \Statex
    \Statex // Pongo en 0 los nuevos d\'ias que llegaron
    \State $i \gets 0$\Comment{O(1)}
    \While{$i < diff \land i < 3$}\Comment{$3 * 2O(1) = O(1)$}
        \State $link.accesos[2 - i] \gets 0$\Comment{$O(1)$}
        \State $i \gets i + 1$\Comment{$O(1)$}
    \EndWhile
    \Statex
    \State $link.ultAcceso \gets f$\Comment{$O(1)$}
    \State $link.accesos[2] \gets link.accesos[2] + 1$\Comment{$2O(1) = O(1)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $7O(1) + O(|l|) = O(|l|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iCantLinks(\In{s}{LinkLinkIt}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $categoriaID \gets \Call{ID}{s.aCategorias, c}$\Comment{$O(|c|)$}
	\State $res \gets \Call{Longitud}{s.linksPorCat[categoriaID-1]}$\Comment{$2O(1) = O(1)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|c|) + O(1) = O(|c|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iLinksOrdenadosPorAccesos(\Inout{s}{LinkLinkIt}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{\hyperlink{itLinks}{itLinks}}}
\begin{algorithmic}[1]
    \State $categoriaID \gets \Call{ID}{s.aCategorias, c}$\Comment{$O(|c|)$}
    \State $lista \gets s.linksPorCat[categoriaID - 1]$\Comment{$O(1)$}
    \Statex
    \Statex // Encuentro la fecha m\'as alta de esta categor\'ia.
    \State $it \gets \Call{crearIt}{lista}$\Comment{$O(1)$}
    \State $f \gets 0$\Comment{$O(1)$}
    \While{$\Call{HaySiguiente}{it}$}\Comment{$nO(1) = O(n)$}
        \State $f \gets \Call{max}{\Call{Siguiente}{it}.ultAcceso, f}$\Comment{$O(1)$}
        \State $\Call{Avanzar}{it}$\Comment{$O(1)$}
    \EndWhile
    \Statex
	\Statex // Ya est\'a ordenado?
	\State $it \gets \Call{crearIt}{lista}$
	\State $estaOrdenada \gets \TipoVariable{True}$
	\State $ultPuntaje \gets -1$
	\While{$\Call{HaySiguiente}{it} \land estaOrdenada$}\Comment{$(n + O(1)) * 2O(1) = O(n)$}
		\If{$ultPuntaje > -1$}
			\State $estaOrdenada \gets ultPuntaje \geq \Call{puntajeDelLink}{s, \Call{Siguiente}{it}, f}$\Comment{2O(1)}
		\EndIf
		\State $ultPuntaje \gets \Call{puntajeDelLink}{s, \Call{Siguiente}{it}, f}$\Comment{2O(1)}
	\EndWhile
	\If{$estaOrdenada$}
		\State \Return $res \gets \Call{crearItLinks}{lista, f, s}$\Comment{O(1)}
	\EndIf
	\Statex
	\Statex // Ordeno agregando $n$ veces el de m\'as accesos que encuentre.
	\State $listaOrdenada \gets \Call{Vacia}{\null}$
	\State $itOrd \gets \Call{crearIt}{listaOrdenada}$
	\While{$\neg\Call{Vacia}{lista}$}\Comment{$n * (O(n) + 3O(1)) = O(n^2)$}
		\State $itRes \gets itMaxAccesos \gets \Call{crearIt}{lista}$\Comment{2O(1) = O(1)}
		\While{$\Call{HaySiguiente}{itRes}$}\Comment{$n * 5O(1) = O(n)$}
			\If{$\Call{puntajeDelLink}{s, \Call{Siguiente}{itRes}, f} > \Call{puntajeDelLink}{s, \Call{Siguiente}{itMaxAccesos}, f}$}
				\State $itMaxAccesos \gets itRes$
			\EndIf
		\EndWhile
		\Statex
		\State $\Call{AgregarComoAnterior}{itOrd, \Call{Siguiente}{itMaxAccesos}}$\Comment{O(1)}
		\State $\Call{EliminarSiguiente}{itMaxAccesos}$\Comment{O(1)}
		\Statex
	\EndWhile
	\Statex
	\State $s.linksPorCat[categoriaID-1] \gets listaOrdenada$\Comment{O(1)}
	\State $res \gets \Call{crearItLinks}{listaOrdenada, f, s}$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|c|) + 2O(n) + O(n^2) + 11O(1)= O(|c| + n^2)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iPuntajeDelLink(\In{s}{LinkLinkIt}, \In{il}{infoLink}, \In{ultAccesoCat}{fecha}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
    \State $res \gets 0$\Comment{$O(1)$}
    \State $i \gets 3$\Comment{$O(1)$}
    \While{$f - il.ultAcceso < i$}\Comment{gracias a la Pre $(f - il.ultAcceso) > 0 \Rightarrow 3O(1) = O(1)$}
        \State $i \gets i - 1$\Comment{$O(1)$}
        \State $res \gets res + il.accesos[i]$\Comment{$O(1)$}
    \EndWhile
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $3O(1) = O(1)$
\end{algorithm}

\subsubsection{Algoritmos del Iterador}

\begin{algorithm}[H]
\caption*{iCrearItLinks(\In{ls}{lista(link)}, \In{fecha}{fecha}, \In{s}{LinkLinkIt}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{\hyperlink{itLinks}{itLinks}}}
\begin{algorithmic}[1]
	\State $res.it \gets \Call{crearIt}{ls}$\Comment{O(1)}
	\State $res.ultAcceso \gets fecha$\Comment{O(1)}
	\State $res.s \gets s$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iSiguienteLink(\In{itl}{itLinks}) $\DRef res$ : \TipoVariable{link}}
\begin{algorithmic}[1]
	\State $res \gets \Call{Siguiente}{itl.it}.link$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iSiguienteCategoria(\In{itl}{itLinks}) $\DRef res$ : \TipoVariable{categoria}}
\begin{algorithmic}[1]
	\State $res \gets \Call{Siguiente}{itl.it}.categoria$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iSiguienteAccesosRecientes(\In{itl}{itLinks}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $res \gets \Call{puntajeDelLink}{itl.s, \Call{Siguiente}{itl.it}, itl.fecha}$\Comment{2O(1) = O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iHaySiguiente?(\In{itl}{itLinks}) $\DRef res$ : \TipoVariable{Bool}}
\begin{algorithmic}[1]
	\State $res \gets \Call{HaySiguiente?}{itl.it} \yluego \Call{puntajeDelLink}{itl.s, \Call{Siguiente}{itl.it}, itl.utlAcceso} > 0$\Comment{3O(1) = O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iAvanzar(\Inout{itl}{itLinks})}
\begin{algorithmic}[1]
	\State $\Call{Avanzar}{itl.it}$
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1) = O(1)$
\end{algorithm}

\subsection{Servicios Usados}

\textbf{Los siguientes m\'odulos deben cumplir los compromisos pedidos}

\begin{itemize}
	\item \TipoVariable{Puntero($\alpha$)}
	\begin{itemize}
		\item[\&] debe tener complejidad O(1).
	\end{itemize}

	\item \TipoVariable{abCat}
	\begin{itemize}
		\item[cantCategorias] debe tener complejidad O(1).
		\item[ID] debe tener complejidad O(|c|) donde c es la categor\'ia de la que se desea saber el id.
		\item[padres] debe tener complejidad O(|c|) donde c es la categor\'ia de la que se desea conocer sus padres.
	\end{itemize}

	\item \TipoVariable{itAbCat}
	\begin{itemize}
		\item[hayMasPadres?] debe tener complejidad O(1).
		\item[subir] debe tener complejidad O(1).
		\item[actualID] debe tener complejidad O(1).
	\end{itemize}

	\item \TipoVariable{diccString($\alpha$)}
	\begin{itemize}
		\item[Definir] debe tener complejidad O(|k|) donde k es la clave.
	\end{itemize}

	\item \TipoVariable{Vector($\alpha$)}
	\begin{itemize}
		\item[Vacia] debe tener complejidad O(1).
		\item[AgregarAtras] debe tener complejidad O(n) s\'i y s\'olo s\'i se agregan n elementos de forma consecutiva.
		\item[Longitud] debe tener complejidad O(1).
		\item[$\bullet\begin{bmatrix}\bullet\end{bmatrix}$] debe tener complejidad O(1).
	\end{itemize}

	\item \TipoVariable{Lista Enlazada ($\alpha$)}
	\begin{itemize}
		\item[Vacia] debe tener complejidad O(1).
		\item[AgregarAtras] debe tener complejidad O($copy$($a$)), donde $a$ es el tipo del elemento que va a ser colocado en la lista.
	\end{itemize}

	\item \TipoVariable{itLista($\alpha$)}
	\begin{itemize}
		\item[crearIt] debe tener complejidad O(1).
		\item[HaySiguiente?] debe tener complejidad O(1).
		\item[Avanzar] debe tener complejidad O(1).
		\item[Siguiente] debe tener complejidad O(1).
	\end{itemize}

	\item \TipoVariable{diccString($\alpha$)}
	\begin{itemize}
		\item[Vacio] debe tener complejidad O(1).
		\item[Obtener] debe tener complejidad O(|$k$|) donde $k$ es la clave.
	\end{itemize}
\end{itemize}

\section{M\'odulo Iterador Unidireccional($\alpha$)}

\subsection{Interfaz}

	\textbf{par\'ametro formal}: \TipoVariable{$\alpha$}.

	\textbf{usa}: \TipoVariable{Bool, lista($\alpha$), itLista($\alpha$)}.

	\textbf{se explica con}: \TipoVariable{Iterador Unidireccional($\alpha$)}.

	\textbf{g\'eneros}: \TipoVariable{iteradorUni($\alpha$)}
	
	\modTitulo{Operaciones b\'asicas}

	\InterfazFuncion{crearIterador}{\In{l}{lista($\alpha$)}}{iteradorUni($\alpha$)}
	  {$res \igobs crearItUni(l)$}
	  [$\Theta(1)$]
	  [Crea un iterador unidireccional a la lista de forma tal que al pedir actual se obtenga el primer elemento de l.]

	\InterfazFuncion{HayMas?}{\In{it}{iteradorUni($\alpha$)}}{Bool}
	  {$res \igobs HayMas?(it)$}
	  [$\Theta(1)$]
	  [Devuelve true s\'i y s\'olo s\'i en el iterador todav\'ia quedan elementos por iterar.]

	\InterfazFuncion{Siguiente}{\Inout{it}{iteradorUni($\alpha$)}}{}
	  [$hayMas?(it) \land it \igobs it_0$]
	  {$it \igobs Avanzar(it_0)$}
	  [$\Theta(1)$]
	  [Avanza el iterador a la siguiente posici\'on.]
	  
	 \InterfazFuncion{Actual}{\In{it}{iteradorUni($\alpha$)}}{$\alpha$}
	  {$res \igobs Actual(it)$}
	  [$\Theta(1)$]
	  [Devuelve el elemento al que est\'a apuntando el iterador por referencia. Dicho elemento no debe ser modificado ya que alterar\'ia la lista y eso no est\'a permitido.]

\subsection{Representaci\'on}

	\begin{Estructura}{iteradorUni($\alpha$)}
		\begin{Tupla}
			\tupItem{it}{itLista($\alpha$)}
		\end{Tupla}
	\end{Estructura}
    
\tadAlinearFunciones{Rep}{estr}
\tadAlinearAxiomas{Rep(e)}
\Rep{true}\mbox{}

\tadAlinearFunciones{Abs}{estr\ e}
\tadAlinearAxiomas{Abs(e)}
\AbsFc{iteradorUni($\alpha$)}{it:iteradorUni($\alpha$) $|$ Siguientes(it) $\igobs$ Siguientes(e.it)}

\modTitulo{Justificaci\'on}
Para representar el iterador unidireccional de la lista, decidimos usar el iterador bidireccional que nos provee la lista enlazada y nos permite obtener, del iterador, las operaciones que necesitamos.

\subsection{Algoritmos}

\begin{algorithm}[H]
\caption*{iCrearIterador(\In{l}{lista($\alpha$)}) $\DRef res$ : \TipoVariable{iteradorUni($\alpha$)}}
\begin{algorithmic}[1]
	\State $res.it \gets \Call{CrearIt}{l}$\Comment{$\Theta(1)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iHayMas?(\In{iterador}{iteradorUni($\alpha$)}) $\DRef res$ : \TipoVariable{Bool}}
\begin{algorithmic}[1]
	\State $res \gets \Call{HaySiguiente}{iterador.it}$\Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iSiguiente(\Inout{iterador}{iteradorUni($\alpha$)})}
\begin{algorithmic}[1]
	\State $\Call{Avanzar}{iterador.it}$\Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iActual(\In{iterador}{iteradorUni($\alpha$)}) $\DRef res$ : {$\alpha$}}
\begin{algorithmic}[1]
	\State $res \gets$ \Call{Siguiente}{$iterador.it$}\Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\subsection{Servicios Usados}

\textbf{Los siguientes m\'odulos deben cumplir con los compromisos pedidos:}

\begin{itemize}
	\item \TipoVariable{itLista($\alpha$)}
	\begin{itemize}
		\item[crearIt] debe tener complejidad O(1).
		\item[HaySiguiente] debe tener complejidad O(1).
		\item[Avanzar] debe tener complejidad O(1).
		\item[Siguiente] debe tener complejidad O(1).
	\end{itemize} 
\end{itemize}

\end{document}