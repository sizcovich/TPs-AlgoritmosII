\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{ifthen}
\usepackage{libs/caratula}
\usepackage{libs/aed2-symb,libs/aed2-itef,libs/aed2-tad}
\usepackage{libs/algpseudocode}
\usepackage{algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}

%%--- Nuevos comandos START

\newcommand{\f}[1]{\text{#1}}
\renewcommand{\paratodo}[2]{$\forall~#2$: #1}

\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representaci\'on}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\modTitulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

%%--- Nuevos comandos END

\sloppy

\parskip=5pt % 10pt es el tamaño de fuente

% Pongo en 0 la distancia extra entre itemes.
\let\olditemize\itemize
\def\itemize{\olditemize\itemsep=0pt}

% Acomodo fancyhdr.
\pagestyle{fancy}
\thispagestyle{fancy}
\addtolength{\headheight}{1pt}
\lhead{Algoritmos y Estructuras de Datos II}
\rhead{$2^{\mathrm{do}}$ cuatrimestre de 2012}
\cfoot{\thepage /\pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}

\author{Grupo 3 - Algoritmos y Estructuras de Datos II, 2do Cuatrimestre 2012.}
\date{}
\title{LinkLinkIt}

\begin{document}

\materia{Algoritmos y Estructuras de Datos II}
\submateria{Trabajo Pr\'actico de Dise\~no}
\titulo{LinkLinkIt}
\subtitulo{Cat\'alogo de rutas en internet}
\grupo{3}
\integrante{Barabas, Ariel}{775/11}{ariel.baras@gmail.com}
\integrante{Izcovich, Sabrina}{550/11}{sizcovich@gmail.com}
\integrante{Otero, Fernando}{424/11}{fergabot@gmail.com}
\integrante{Vita, Sebasti\'an}{149/11}{sebastian\_vita@yahoo.com.ar}

%Pagina de titulo e indice
\thispagestyle{empty}

\maketitle

\section{M\'odulo DiccTrie($\alpha$)}
\begin{Interfaz}

	\textbf{par\'ametro formal}: \TipoVariable{$\alpha$}.

	\textbf{usa}: \TipoVariable{Bool, String}.

	\textbf{se explica con}: \TipoVariable{Diccionario(String, $\alpha$)}.

	\textbf{g\'eneros}: \TipoVariable{diccTrie($\alpha$)}.

	\modTitulo{Operaciones b\'asicas}

	\InterfazFuncion{Vacio}{}{diccTrie($\alpha$)}
	  {$res \igobs vacio()$}
	  [O(1)]
	  [Genera un diccionario vac\'io.]

	\InterfazFuncion{Definir}{\Inout{d}{diccTrie}, \In{k}{string}, \In{s}{$\alpha$}}{}
	  [$d \igobs d_0$]
	  {$d \igobs definir(d_0, k, s)$}
	  [O(|$k$|)]
	  [Define la clave $k$ con el significado $s$ en el diccionario.]
	  [La clave se guarda por copia y el significado por referencia.]

	\InterfazFuncion{Definido?}{\Inout{d}{diccTrie}, \In{k}{string}}{Bool}
	  {$res \igobs def?(d, k)$}
	  [O(|$k$|)]
	  [Devuelve \TipoVariable{True} si y s\'olo si $k$ est\'a definido en el diccionario.]

	\InterfazFuncion{Obtener}{\Inout{d}{diccTrie}, \In{k}{string}}{$\alpha$}
	  [$def?(d, k)$]
	  {$alias(res \igobs obtener(d, k))$}
	  [O(|$k$|)]
	  [Devuelve el significado por referencia de la clave $k$ en $d$.]

\end{Interfaz}

\begin{Representacion}

\end{Representacion}

\section{M\'odulo ArbolCategorias}
\begin{Interfaz}

	\textbf{usa}: \TipoVariable{Nat, String, diccTrie($\alpha$), lista($\alpha$), itLista($\alpha$)}.

	\textbf{se explica con}: \TipoVariable{ArbolCategorias, Iterador Unidireccional($\alpha$)}.

	\textbf{g\'eneros}: \TipoVariable{abCat} %, \TipoVariable{itCategorias}.

	\modTitulo{Operaciones b\'asicas}

	\InterfazFuncion{nuevoAC}{\In{raiz}{categoria}}{abCat}
	  {$res \igobs nuevo(raiz)$}
	  [$\Theta(|raiz|)$]
	  [Crea un \'arbol con categor\'ia \emph{raiz}.]

	\InterfazFuncion{raiz}{\In{ac}{abCat}}{categoria}
	  {$res \igobs raiz(ac)$}
	  [$\Theta(1)$]
	  [Devuelve el nombre de la categor\'ia raiz por referencia, con lo cual, si \'este valor es modificado, se romper\'a el Rep, invalidando todo el \'arbol.]

	\InterfazFuncion{agregar}{\Inout{ac}{abCat}, \In{padre}{categoria}, \In{hija}{categoria}}{categoria}
	  [$ac$ \igobs $ac_0$ $\land$ est\'a?(padre, ac) $\land$ $\neg$vac\'ia?(hija) $\land$ $\neg$est\'a?(hija, ac)]
	  {$ac \igobs agregar(ac_0, padre, hija)$}
	  [$\Theta(|padre| + |hija|)$]
	  [Agrega la categor\'ia hija a padre.]

	\InterfazFuncion{hijas}{\In{ac}{abCat}, \In{padre}{categoria}}{iteradorUni(categoria)}
	  [est\'a?(padre, ac)]
	  {$res \igobs crearItUni(conjuntoASecuencia(hijos(ac, padre)))$}
	  [$\Theta(|padre|)$]
	  [Devuelve un iterador que proyecta las hijas del padre de forma tal que al pedir actual, el iterador devuelve el primer elemento de la lista.]
	  [El iterador se invalida si y solo si se elimina el elemento siguiente del iterador sin utilizar la funcion EliminarSiguiente]

	\InterfazFuncion{id}{\In{ac}{abCat}, \In{c}{categoria}}{Nat}
	  [est\'a?(c, ac)]
	  {$res \igobs id(ac, c)$}
	  [$\Theta(|c|)$]
	  [Devuelve el id de la categoria dada.]

\end{Interfaz}

\begin{tad}{Extras}

	\tadOperacion{conjuntoASecuencia}{Conjunto($\alpha$)}{Secuencia($\alpha$)}{}
	\tadAlinearAxiomas{conjuntoASecuencia(Ag(a, as))}
	\tadAxioma{conjuntoASecuencia($\emptyset$)}{<>}
	\tadAxioma{conjuntoASecuencia(Ag($a$, $as$))}{dameUno(Ag($a$, $as$)) $\bullet$ conjuntoASecuencia(sinUno(Ag($a$, $as$)))}

\end{tad}

\begin{Representacion}

	\begin{Estructura}{abCat}
	    \begin{Tupla}
	      \tupItem{categorias}{DiccTrie(categoria, catInfo)}
	      \tupItem{raiz}{categoria}
	      \tupItem{ultID}{nat}
	    \end{Tupla}

	    \begin{Tupla}[catInfo]
	      \tupItem{id}{nat}
	      \tupItem{hijas}{lista(categoria)}
	    \end{Tupla}
	\end{Estructura}

\end{Representacion}

\begin{Algoritmos}

\algdef{SL}{var}{0}[2]{$#1$ \textbf{es} \TipoVariable{#2}}

\begin{algorithm}[H]
\caption{iNuevoAC(\In{raiz}{categoria}) $\DRef res$ : \TipoVariable{abCat}}
\begin{algorithmic}[1]
	\State $res.categorias \gets $Vacio()\Comment{O(1)}
	\State $res.raiz\gets raiz$\Comment{O(|$raiz$|)}
	\State $res.ultID\gets 1$\Comment{O(1)}
	\Statex
	\var{infoRaiz}{catInfo}
	\State $infoRaiz.id \gets res.ultID$\Comment{O(1)}
	\State $infoRaiz.hijas \gets$ Vacia()\Comment{O(1)}
	\State Definir($res.categorias$, $raiz$, $infoRaiz$)\Comment{O(|$raiz$|)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: 4O(1) + O(|$raiz$|) + O(|$raiz$|) = 2O(|$raiz$|) = O(|$raiz$|)
\end{algorithm}

\begin{algorithm}[H]
\caption{iRaiz(\In{ac}{abCat}) $\DRef res$ : \TipoVariable{categoria}}
\begin{algorithmic}[1]
	\State $res \gets ac.raiz$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: O(1)
\end{algorithm}

\begin{algorithm}[H]
\caption{iAgregar(\Inout{ac}{abCat}, \In{padre}{categoria}, \In{hija}{categoria})}
\begin{algorithmic}[1]
	\State $ac.ultID \gets ac.ultID + 1$\Comment{O(1)}
	\Statex
	\var{infoHija}{catInfo}
	\State $infoHija.id \gets ac.ultID$\Comment{O(1)}
	\State $infoHija.hijas \gets$ Vacia()\Comment{O(1)}
	\State Definir($ac.categorias$, $hija$, $infoHija$)\Comment{O(|$hija$|)}
	\Statex
	\State $infoPadre \gets$ Obtener($ac.categorias$, $padre$)\Comment{O(|$padre$|)}
	\State AgregarAtras($infoPadre.hijas$, $hija$)\Comment{O(|$hija$|)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: 3O(1) + O(|$hija$|) + O(|$padre$|) + O(|$hija$|) = 2O(|$hija$|) + O(|$padre$|) = O(|$hija$|) + O(|$padre$|) = O(|$hija$| + |$padre$|)
\end{algorithm}

\begin{algorithm}[H]
\caption{iHijas(\In{ac}{abCat}, \In{padre}{categoria}) $\DRef res$ : \TipoVariable{iteradorUni(categoria)}}
\begin{algorithmic}[1]
	\State $nodoHijo \gets$ Obtener($ac.categorias$, $padre$)\Comment{O(|$padre$|)}
	\State $res \gets$ crearIterador($nodoHijo.hijas$)\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: O(|$padre$|) + O(1) = O(|$padre$|)
\end{algorithm}

\begin{algorithm}[H]
\caption{iID(\In{ac}{abCat}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $nodoHijo \gets$ Obtener($ac.categorias$, $c$)\Comment{O(|$c$|)}
	\State $res \gets$ $nodoHijo.id$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: O(|$c$|) + O(1) = O(|$c$|)
\end{algorithm}

\end{Algoritmos}

\modTitulo{Servicios Usados}

\textbf{Los siguientes módulos deben cumplir los compromisos pedidos a continuación:}

\modTitulo{Lista Enlazada ($\alpha$)}

La función Vacia debe tener complejidad O(1)\\
La función agregarAtras debe tener complejidad O($copy$($a$)), donde $a$ es el tipo del elemento que se va a colocar en la lista.

\modTitulo{Iterador Unidireccional ($\alpha$)}

la función crearIterador debe tener complejidad O(1) 

\modTitulo{DiccTrie ($\alpha$)}

la función Vacio debe tener complejidad O(1) \\
la función Definir debe tener complejidad O(|$k$|) donde $k$ es el string que se va a colocar como definicion. \\
la función Obtener debe tener complejidad O(|$k$|) donde $k$ es la clave

\section{M\'odulo LinkLinkIt}

\begin{Interfaz}
	
	\InterfazFuncion{crearLinkLinkIt}{\In{ac}{abCat}}{LinkLinkIt}
	  {$res \igobs iniciar(ac)$}
	  [$\Theta(\#categorias(ac))$]
	  [Crea un sistema LinkLinkIt.]

	\InterfazFuncion{agregarLink}{\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{c}{categoria}}{LinkLinkIt}
	  [$l \notin$ links($s$) $\land$ est\'a?($c$, categorias($s$)) $\land$ $s \igobs s_0$]
	  {$s \igobs nuevoLink(s_0, l, c)$}
	  [$\Theta(|l| + |c|)$]
	  [Agrega un link a la categor\'ia se\~{n}alada.]

	\InterfazFuncion{accederLink}{\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{f}{fecha}}{LinkLinkIt}
	  [$l \in$ links($s$) $\land$ $f \geq$ fechaActual($s$)]
	  {$s \igobs$ nuevoLink($s_0$, $l$, $c$)}
	  [$\Theta(|l| + |c|)$]
	  [Registra un acceso al link provisto.]

	\InterfazFuncion{cantLinks}{\Inout{s}{LinkLinkIt}, \In{c}{categoria}}{Nat}
	  {$res \igobs$ cantLinks($s$, $c$)}
	  [$\Theta(|c|)$]
	  [Devuelve la cantidad de links que tiene una categor\'ia.]

	\InterfazFuncion{linksOrdenadosPorAccesos}{\Inout{s}{LinkLinkIt}, \In{c}{categoria}}{itLinks}
	  [est\'a?($c$, categorias($s$))]
	  {$res \igobs$ crearIteradorLinksOrdenadosPorAccesos($s$, $c$)}
	  [$\Theta(|c| + n^2)$]
	  [Devuelve la cantidad de links que tiene una categor\'ia.]

\end{Interfaz}

\begin{Representacion}

	\begin{Estructura}{LinkLinkIt}
	    \begin{Tupla}
	      \tupItem{aCategorias}{abcat}%
	      \tupItem{linksPorCat}{vector(conj(link))}%
	      \tupItem{\\ infoLinks}{DiccTrie(link,tupla<categoria, secu(accesos)>)}%
	    \end{Tupla}

	\end{Estructura}

\end{Representacion}

REP Y ABS

\begin{Algoritmos}

\algdef{SL}{var}{0}[2]{$#1$ \textbf{es} \TipoVariable{#2}}

\begin{algorithm}[H]
\caption{iCrearLinkLinkIt(\In{ac}{abCat}) $\DRef res$ : \TipoVariable{LinkLinkIt}}
\begin{algorithmic}[1]
	\State $res$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{iAgregarLink(\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{c}{categoria})}
\begin{algorithmic}[1]
	\State $res$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{iAccederLink(\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{f}{fecha})}
\begin{algorithmic}[1]
	\State $res$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{iCantLinks(\Inout{s}{LinkLinkIt}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $res$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{iLinksOrdenadosPorAccesos(\Inout{s}{LinkLinkIt}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{itLinks}}
\begin{algorithmic}[1]
	\State $res$
\end{algorithmic}
\end{algorithm}

\end{Algoritmos}


\section{M\'odulo Iterador Unidireccional($\alpha$)}

\begin{Interfaz}

	\textbf{par\'ametro formal}: \TipoVariable{$\alpha$}.

	\textbf{usa}: \TipoVariable{Bool}.

	\textbf{se explica con}: \TipoVariable{Iterador Unidireccional($\alpha$)}.

	\textbf{g\'eneros}: \TipoVariable{iteradorUni($\alpha$)}

	\InterfazFuncion{crearIterador}{\In{l}{lista($\alpha$)}}{iteradorUni($\alpha$)}
	  {$res \igobs crearItUni(l)$}

	\InterfazFuncion{HayMas?}{\In{it}{iteradorUni($\alpha$)}}{Bool}
	  {$res \igobs HayMas?(it)$}

	\InterfazFuncion{Siguiente}{\Inout{it}{iteradorUni($\alpha$)}}{$\alpha$}
	  [$hayMas?(it) \land it \igobs it_0$]
	  {$it \igobs Avanzar(it_0) \land res \igobs Actual(it)$}

\end{Interfaz}

\begin{Representacion}

	\begin{Estructura}{iteradorUni($\alpha$)}
		\begin{Tupla}
			\tupItem{lista}{lista($\alpha$)}
		\end{Tupla}
	\end{Estructura}

\end{Representacion}

\begin{Algoritmos}

\begin{algorithm}[H]
\caption{iCrearIterador(\In{l}{lista($\alpha$)}) $\DRef res$ : \TipoVariable{iteradorUni($\alpha$)}}
\begin{algorithmic}[1]
	\State $res.lista \gets l$\Comment{O(1)}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{iHayMas?(\In{it}{iteradorUni($\alpha$)}) $\DRef res$ : \TipoVariable{Bool}}
\begin{algorithmic}[1]
	\State $res \gets \neg $EsVac\'ia?($it.lista$)\Comment{$\Theta(1)$}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{iSiguiente(\Inout{it}{iteradorUni($\alpha$)}) $\DRef res$ : \TipoVariable{$\alpha$}}
\begin{algorithmic}[1]
	\State $it.lista \gets$ Fin($it.lista$)\Comment{$\Theta(1)$}
	\State $res \gets$ Actual($it.lista$)\Comment{$\Theta(1)$}
\end{algorithmic}
\end{algorithm}

\end{Algoritmos}

\section{Módulo Lista Enlazada($\alpha$)}


\begin{Interfaz}
  
  \textbf{parámetros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{géneros}} $\alpha$\\
  \parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
    {$res \igobs a$}
    [$\Theta(copy(a))$]
    [Función de copia de $\alpha$'s]
  }

  \textbf{se explica con}: \tadNombre{Secuencia$(\alpha)$}, \tadNombre{Iterador Bidireccional($\alpha$)}.

  \textbf{géneros}: \TipoVariable{lista$(\alpha)$}, \TipoVariable{itLista($\alpha$)}.

  \modTitulo{Operaciones básicas de lista}

  \InterfazFuncion{Vacía}{}{lista$(\alpha)$}%
  {$res \igobs \secuencia{}$}%
  [$\Theta(1)$]
  [Genera una lista vacía.]

  \InterfazFuncion{AgregarAdelante}{\Inout{l}{lista($\alpha$)}, \In{a}{$\alpha$}}{itLista($\alpha$}
  [$l \igobs l_0$]
  {$l \igobs \secuencia{a}[l_0]$ $\land$ $res$ $=$ CrearItBi(\secuencia{}, $l$) $\land$ alias(SecuSuby($res$) $=$ $l$)}
  [$\Theta(copy(a))$]
  [Agrega el elemento $a$ como primer elemento de la lista.  Retorna un iterador a $l$, de forma tal que Siguiente devuelva $a$.]
  [El elemento $a$ agrega por copia. El iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función \NombreFuncion{EliminarSiguiente}.]

 
  \modTitulo{Operaciones del iterador}

  \InterfazFuncion{CrearIt}{\In{l}{lista($\alpha$)}}{itLista($\alpha$)}
  {$res$ $\igobs$ crearItBi(\secuencia{}, $l$) $\land$ alias(SecuSuby($it$) $=$ $l$)}
  [$\Theta(1)$]
  [Crea un iterador bidireccional de la lista, de forma tal que al pedir \NombreFuncion{Siguiente} se obtenga el primer elemento de $l$.]
  [El iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función \NombreFuncion{EliminarSiguiente}.]

  \InterfazFuncion{CrearItUlt}{\In{l}{lista($\alpha$)}}{itLista($\alpha$)}
  {$res$ $\igobs$ crearItBi($l$, \secuencia{}) $\land$ alias(SecuSuby($it$) $=$ $l$)}
  [$\Theta(1)$]
  [Crea un iterador bidireccional de la lista, de forma tal que al pedir \NombreFuncion{Anterior} se obtenga el último elemento de $l$.]  
  [El iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función \NombreFuncion{EliminarSiguiente}.]

\end{Interfaz}

\begin{Representacion}
  
  \modTitulo{Representación de la lista}

  \begin{Estructura}{lista$(\alpha)$}[lst]
    \begin{Tupla}[lst]
      \tupItem{primero}{puntero(nodo)}%
      \tupItem{longitud}{nat}%
    \end{Tupla}

    \begin{Tupla}[nodo]
      \tupItem{dato}{$\alpha$}%
      \tupItem{anterior}{puntero(nodo)}%
      \tupItem{siguiente}{puntero(nodo)}%
    \end{Tupla}
  \end{Estructura}

  \Rep[lst][l]{($l$.primero $=$ NULL) $=$ ($l$.longitud $=$ $0$) $\yluego$ ($l$.longitud $\neq$ $0$ \impluego \\
    Nodo($l$, $l$.longitud) $=$ $l$.primero $\land$ \\
    ($\forall i$: nat)(Nodo($l$,$i$)\DRef siguiente $=$ Nodo($l$,$i+1$)\DRef anterior) $\land$ \\
    ($\forall i$: nat)($1 \leq i <$ $l$.longitud $\implies$ Nodo($l$,$i$) $\neq$ $l$.primero)}\mbox{}

  ~      

  \tadOperacion{Nodo}{lst/l,nat}{puntero(nodo)}{$l$.primero $\neq$ NULL}
  \tadAxioma{Nodo($l$,$i$)}{\IF $i = 0$ THEN $l$.primero ELSE Nodo(FinLst($l$), $i-1$) FI}

  ~

  \tadOperacion{FinLst}{lst}{lst}{}
  \tadAxioma{FinLst($l$)}{Lst($l$.primero\DRef siguiente, $l$.longitud $-$ $\min$\{$l$.longitud, $1$\})}

  ~

  \tadOperacion{Lst}{puntero(nodo),nat}{lst}{}
  \tadAxioma{Lst($p,n$)}{$\langle p, n\rangle$}

  ~
 
  \AbsFc[lst]{secu($\alpha$)}[l]{\IF $l$.longitud $=$ $0$ THEN \secuencia{} ELSE \secuencia{$l$.primero\DRef dato}[Abs(FinLst($l$))] FI}

  \modTitulo{Representación del iterador}

  \begin{Estructura}{itLista($\alpha$)}[iter]
    \begin{Tupla}[iter]
      \tupItem{siguiente}{puntero(nodo)}%
      \tupItem{lista}{puntero(lst)}%
    \end{Tupla}
  \end{Estructura}

  \Rep[iter][it]{Rep($\ast$($it$.lista)) $\yluego$ ($it$.siguiente $=$ NULL $\oluego$ ($\exists i$: nat)(Nodo($\ast it$.lista, $i$) $=$ $it$.siguiente)}

  ~

  \Abs[iter]{itBi($\alpha$)}[it]{b}{Siguientes($b$) $=$ Abs(Sig($it$.lista, $it$.siguiente)) $\land$\\
    Anteriores($b$) $=$ Abs(Ant($it$.lista, $it$.siguiente))}

  ~

  \tadOperacion{Sig}{puntero(lst)/l,puntero(nodo)/p}{lst}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Sig($i, p$)}{Lst($p$, $l$\DRef longitud $-$ Pos($\ast l$, $p$))}

  ~

  \tadOperacion{Ant}{puntero(lst)/l,puntero(nodo)/p}{lst}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Ant($i, p$)}{Lst(\IF $p$ $=$ $l$\DRef primero THEN NULL ELSE $l$\DRef primero FI, Pos($\ast l$, $p$))}

  ~

  {\small Nota: cuando $p$ $=$ NULL, Pos devuelve la longitud de la lista, lo cual está bien, porque significa que el iterador no tiene siguiente.}
  \tadOperacion{Pos}{lst/l,puntero(nodo)/p}{puntero(nodo)}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Pos($l$,$p$)}{\IF $l$.primero $=$ $p$ $\lor$ $l$.longitud $=$ $0$ THEN $0$ ELSE $1$ $+$ Pos(FinLst($l$), $p$) FI}


\end{Representacion}

\end{document}