\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{ifthen}
\usepackage{libs/caratula}
\usepackage{libs/aed2-symb,libs/aed2-itef,libs/aed2-tad}
\usepackage{fixltx2e}
\usepackage{caption}
\usepackage{algpseudocode}
\usepackage[section]{algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}

%%--- Nuevos comandos START

\MakeRobust{\Call}
\algdef{SL}{var}{0}[2]{$#1$ \textbf{es} \TipoVariable{#2}}

\newcommand{\f}[1]{\text{#1}}
\renewcommand{\paratodo}[2]{$\forall~#2$: #1}

\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representaci\'on}%
  \vspace*{2ex}%
}{}

\newenvironment{Servicios Usados}{%
  \vspace*{2ex}
  \noindent\textbf{\Large Servicios Usados}%
  \vspace*{2ex}
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}

\newenvironment{Justificacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Justificaci\'on de la elecci\'on de la estructura}%
  \vspace*{2ex}%
}{}

\newcommand{\modTitulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

%%--- Nuevos comandos END

\sloppy

\parskip=5pt % 10pt es el tamaño de fuente

% Pongo en 0 la distancia extra entre itemes.
\let\olditemize\itemize
\def\itemize{\olditemize\itemsep=0pt}

% Acomodo fancyhdr.
\pagestyle{fancy}
\thispagestyle{fancy}
\addtolength{\headheight}{1pt}
\lhead{Algoritmos y Estructuras de Datos II}
\rhead{$2^{\mathrm{do}}$ cuatrimestre de 2012}
\cfoot{\thepage /\pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}

\author{Grupo 3 - Algoritmos y Estructuras de Datos II, 2do Cuatrimestre 2012.}
\date{}
\title{LinkLinkIt}

\begin{document}

\materia{Algoritmos y Estructuras de Datos II}
\submateria{Trabajo Pr\'actico de Dise\~no}
\titulo{LinkLinkIt}
\subtitulo{Cat\'alogo de rutas en internet}
\grupo{3}
\integrante{Barabas, Ariel}{775/11}{ariel.baras@gmail.com}
\integrante{Izcovich, Sabrina}{550/11}{sizcovich@gmail.com}
\integrante{Otero, Fernando}{424/11}{fergabot@gmail.com}
\integrante{Vita, Sebasti\'an}{149/11}{sebastian\_vita@yahoo.com.ar}

%Pagina de titulo e indice
\thispagestyle{empty}

\maketitle
\tableofcontents
\newpage

\section{M\'odulo DiccTrie($\alpha$)}
\begin{Interfaz}

	\textbf{par\'ametro formal}: \TipoVariable{$\alpha$}.

	\textbf{usa}: \TipoVariable{Bool, String}.

	\textbf{se explica con}: \TipoVariable{Diccionario(String, $\alpha$)}.

	\textbf{g\'eneros}: \TipoVariable{diccTrie($\alpha$)}.

	\modTitulo{Operaciones b\'asicas}

	\InterfazFuncion{Vacio}{}{diccTrie($\alpha$)}
	  {$res \igobs vacio()$}
	  [O(1)]
	  [Genera un diccionario vac\'io.]

	\InterfazFuncion{Definir}{\Inout{d}{diccTrie}, \In{k}{string}, \In{s}{$\alpha$}}{}
	  [$d \igobs d_0$]
	  {$d \igobs definir(d_0, k, s)$}
	  [O(|$k$|)]
	  [Define la clave $k$ con el significado $s$ en el diccionario.]
	  [La clave se guarda por copia y el significado por referencia.]

	\InterfazFuncion{Definido?}{\Inout{d}{diccTrie}, \In{k}{string}}{Bool}
	  {$res \igobs def?(d, k)$}
	  [O(|$k$|)]
	  [Devuelve \TipoVariable{True} si y s\'olo si $k$ est\'a definido en el diccionario.]

	\InterfazFuncion{Obtener}{\Inout{d}{diccTrie}, \In{k}{string}}{$\alpha$}
	  [$def?(d, k)$]
	  {$alias(res \igobs obtener(d, k))$}
	  [O(|$k$|)]
	  [Devuelve el significado por referencia de la clave $k$ en $d$.]

\end{Interfaz}

\begin{Representacion}

\end{Representacion}

\section{M\'odulo ArbolCategorias}
\begin{Interfaz}

	\textbf{usa}: \TipoVariable{Nat, String, diccTrie($\alpha$), lista($\alpha$), itLista($\alpha$)}.

	\textbf{se explica con}: \TipoVariable{ArbolCategorias, Iterador Unidireccional($\alpha$)}.

	\textbf{g\'eneros}: \TipoVariable{abCat} %, \TipoVariable{itCategorias}.

	\modTitulo{Operaciones b\'asicas}

	\InterfazFuncion{nuevoAC}{\In{raiz}{categoria}}{abCat}
	  {$res \igobs nuevo(raiz)$}
	  [$\Theta(|raiz|)$]
	  [Crea un \'arbol con categor\'ia \emph{raiz}.]

	\InterfazFuncion{raiz}{\In{ac}{abCat}}{categoria}
	  {$res \igobs raiz(ac)$}
	  [$\Theta(1)$]
	  [Devuelve el nombre de la categor\'ia raiz por referencia, con lo cual, si \'este valor es modificado, se romper\'a el Rep, invalidando todo el \'arbol.]

	\InterfazFuncion{agregar}{\Inout{ac}{abCat}, \In{padre}{categoria}, \In{hija}{categoria}}{}
	  [$ac$ \igobs $ac_0$ $\land$ est\'a?(padre, ac) $\land$ $\neg$vac\'ia?(hija) $\land$ $\neg$est\'a?(hija, ac)]
	  {$ac \igobs agregar(ac_0, padre, hija)$}
	  [$\Theta(|padre| + |hija|)$]
	  [Agrega la categor\'ia hija a padre.]

	\InterfazFuncion{hijas}{\In{ac}{abCat}, \In{padre}{categoria}}{iteradorUni(categoria)}
	  [est\'a?(padre, ac)]
	  {$res \igobs crearItUni(conjuntoASecuencia(hijos(ac, padre)))$}
	  [$\Theta(|padre|)$]
	  [Devuelve un iterador que proyecta las hijas del padre de forma tal que al pedir actual, el iterador devuelve el primer elemento de la lista.]
	  [El iterador se invalida si y s\'olo si se elimina el elemento siguiente del iterador sin utilizar la funci\'on EliminarSiguiente]

	\InterfazFuncion{ID}{\In{ac}{abCat}, \In{c}{categoria}}{Nat}
	  [est\'a?(c, ac)]
	  {$res \igobs id(ac, c)$}
	  [$\Theta(|c|)$]
	  [Devuelve el id de la categor\'ia dada.]

	\InterfazFuncion{cantCategorias}{\In{ac}{abCat}}{Nat}
	  {$res \igobs \#categorias(ac)$}
	  [$\Theta(1)$]
	  [Devuelve la cantidad de categor\'ias existentes en el \'arbol.]

\end{Interfaz}

\modTitulo{Funciones auxiliares}

	\tadOperacion{conjuntoASecuencia}{Conjunto($\alpha$)}{Secuencia($\alpha$)}{}
	\tadAlinearAxiomas{conjuntoASecuencia(Ag(a, as))}
	\tadAxioma{conjuntoASecuencia($\emptyset$)}{<>}
	\tadAxioma{conjuntoASecuencia(Ag($a$, $as$))}{dameUno(Ag($a$, $as$)) $\bullet$ conjuntoASecuencia(sinUno(Ag($a$, $as$)))}

\begin{Representacion}

	\begin{Estructura}{abCat}
	    \begin{Tupla}
	      \tupItem{categorias}{DiccTrie(categoria, catInfo)}
	      \tupItem{raiz}{categoria}
	      \tupItem{ultID}{Nat}
	    \end{Tupla}

	    \begin{Tupla}[catInfo]
	      \tupItem{id}{Nat}
	      \tupItem{padre}{puntero(catInfo)}
	      \tupItem{hijas}{lista(categoria)}
	    \end{Tupla}
	\end{Estructura}

\end{Representacion}


\begin{Justificacion}
\\Para representar el árbol de categorías elegimos esta estructura por los siguientes motivos:
\\En primer lugar, el Diccionario Trie modulariza perfectamente un \'arbol de categor\'ias dado que es posible conocer los hijos de cada una de las categor\'ias con la complejidad requerida, para esto, se coloco en cada nodo una lista con los nombres de cada hijo. 
\\En segundo lugar, esta estructura nos permite acceder a la ra\'iz del arbol en O(1) y al ID de cada categor\'ia en O(|c|) donde c es el nombre de la categor\'ia.
%\\El iterador que recorre el arbol hacia arriba será necesario en el LinkLinkIt
\end{Justificacion}

\begin{Algoritmos}

\begin{algorithm}[H]
\caption*{iNuevoAC(\In{raiz}{categoria}) $\DRef res$ : \TipoVariable{abCat}}
\begin{algorithmic}[1]
	\State $res.categorias \gets$ \Call{Vacio}{\null}\Comment{O(1)}
	\State $res.raiz \gets raiz$\Comment{O(|$raiz$|)}
	\State $res.ultID \gets 1$\Comment{O(1)}
	\Statex
	\var{infoPadre}{catInfo}
	\State $infoPadre.id \gets 0$\Comment{O(1)}
	\State $infoPadre.padre \gets \&infoPadre$\Comment{O(1)}
	\State $infoPadre.hijas \gets$ \Call{Vacia}{\null}\Comment{O(1)}
	\Statex
	\var{infoRaiz}{catInfo}
	\State $infoRaiz.id \gets res.ultID$\Comment{O(1)}
	\State $infoRaiz.padre \gets \&infoPadre$\Comment{O(1)}
	\State $infoRaiz.hijas \gets$ \Call{Vacia}{\null}\Comment{O(1)}
	\State \Call{Definir}{$res.categorias, raiz, infoRaiz$}\Comment{O(|$raiz$|)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $9O(1) + 2O(|raiz|) = O(|raiz|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iRaiz(\In{ac}{abCat}) $\DRef res$ : \TipoVariable{categoria}}
\begin{algorithmic}[1]
	\State $res \gets ac.raiz$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iAgregar(\Inout{ac}{abCat}, \In{padre}{categoria}, \In{hija}{categoria})}
\begin{algorithmic}[1]
	\State $ac.ultID \gets ac.ultID + 1$\Comment{O(1)}
	\State $infoPadre \gets$ \Call{Obtener}{$ac.categorias, padre$}\Comment{O(|$padre$|)}
	\Statex
	\var{infoHija}{catInfo}
	\State $infoHija.id \gets ac.ultID$\Comment{O(1)}
	\State $infoHija.padre \gets \&infoPadre$\Comment{O(1)}
	\State $infoHija.hijas \gets$ \Call{Vacia}{\null}\Comment{O(1)}
	\State \Call{Definir}{$ac.categorias, hija, infoHija$}\Comment{O(|$hija$|)}
	\Statex
	\State \Call{AgregarAtras}{$infoPadre.hijas, hija$}\Comment{O(|$hija$|)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $4O(1) + 2O(|hija|) + O(|padre|) = O(|hija|) + O(|padre|) = O(|hija| + |padre|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iHijas(\In{ac}{abCat}, \In{padre}{categoria}) $\DRef res$ : \TipoVariable{iteradorUni(categoria)}}
\begin{algorithmic}[1]
	\State $nodoHijo \gets$ \Call{Obtener}{$ac.categorias, padre$}\Comment{O(|$padre$|)}
	\State $res \gets$ \Call{crearIterador}{$nodoHijo.hijas$}\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|padre|) + O(1) = O(|padre|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iID(\In{ac}{abCat}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $catInfo \gets$ \Call{Obtener}{$ac.categorias, c$}\Comment{O(|$c$|)}
	\State $res \gets catInfo.id$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|c|) + O(1) = O(|c|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iCantCategorias(\In{ac}{abCat}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $res \gets ac.ultId$\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1)$
\end{algorithm}

\end{Algoritmos}

\begin{Servicios Usados}

\textbf{Los siguientes m\'odulos deben cumplir los compromisos pedidos a continuaci\'on:}

\modTitulo{Lista Enlazada ($\alpha$)}

La función Vacia debe tener complejidad O(1)\\
La función agregarAtras debe tener complejidad O($copy$($a$)), donde $a$ es el tipo del elemento que se va a colocar en la lista.

\modTitulo{Iterador Unidireccional ($\alpha$)}

la función crearIterador debe tener complejidad O(1) 

\modTitulo{DiccTrie ($\alpha$)}

la función Vacio debe tener complejidad O(1) \\
la función Definir debe tener complejidad O(|$k$|) donde $k$ es el string que se va a colocar como definicion. \\
la función Obtener debe tener complejidad O(|$k$|) donde $k$ es la clave

\end{Servicios Usados}

\section{M\'odulo LinkLinkIt}

\begin{Interfaz}
	
	\InterfazFuncion{crearLinkLinkIt}{\In{ac}{abCat}}{LinkLinkIt}
	  {$res \igobs iniciar(ac)$}
	  [$\Theta(\#categorias(ac))$]
	  [Crea un sistema LinkLinkIt. El arbol de categor\'ias se guarda por refencia.]

	\InterfazFuncion{agregarLink}{\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{c}{categoria}}{}
	  [$s \igobs s_0$ $\land$ $l \notin links(s)$ $\land$ \emph{est\'a}?$(c, categorias(s))$]
	  {$s \igobs nuevoLink(s_0, l, c)$}
	  [$\Theta(|l| + |c| + h)$]
	  [Agrega un link a la categor\'ia se\~{n}alada.]

	\InterfazFuncion{accederLink}{\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{f}{fecha}}{}
	  [$s \igobs s_0$ $\land$ $l \in$ links($s$) $\land$ $f \geq$ fechaActual($s$)]
	  {$s \igobs acceso(s_0, l, f)$}
	  [$\Theta(|l|)$]
	  [Registra un acceso al link provisto.]

	\InterfazFuncion{cantLinks}{\In{s}{LinkLinkIt}, \In{c}{categoria}}{Nat}
	  {$res \igobs cantLinks(s, c)$}
	  [$\Theta(|c|)$]
	  [Devuelve la cantidad de links que tiene una categor\'ia y sus hijas]

	\InterfazFuncion{linksOrdenadosPorAccesos}{\Inout{s}{LinkLinkIt}, \In{c}{categoria}}{itLinks}
	  [\emph{est\'a}?$(c, categorias(s))$]
	  {$res \igobs crearIteradorLinksOrdenadosPorAccesos(s, c)$}
	  [$\Theta(|c| + n^2)$]
	  [Devuelve la cantidad de links que tiene una categor\'ia.]

\end{Interfaz}

\begin{Representacion}

	\begin{Estructura}{LinkLinkIt}
	    \begin{Tupla}
	      \tupItem{aCategorias}{abcat}
	      \tupItem{\\ linksPorCat}{vector(lista(link))}
	      \tupItem{\\ infoLinks}{DiccTrie(link, infoLink)}
	    \end{Tupla}

		\begin{Tupla}[infoLink]
			\tupItem{categoria}{categoria}
			\tupItem{accesos}{lista(fecha)}
		\end{Tupla}
	\end{Estructura}

\end{Representacion}

REP Y ABS

\begin{Algoritmos}

\begin{algorithm}[H]
\caption*{iCrearLinkLinkIt(\In{ac}{abCat}) $\DRef res$ : \TipoVariable{LinkLinkIt}}
\begin{algorithmic}[1]
	\State $res.aCategorias \gets ac$\Comment{$\Theta$(1)}
	\State $res.linksPorCat \gets$ \Call{Vacia}{\null}\Comment{$\Theta$(1)}
	\State $res.infoLinks \gets$ \Call{Vacio}{\null}\Comment{$\Theta$(1)}
	\Statex
	\For {$i = 1 \to \Call{cantCategorias}{ac}$} \Comment{$O(1) + \#categorias(ac) * \Theta(1) = \Theta(\#categorias(ac))$}
	\State \Call{AgregarAtras}{$res.linksPorCat, \Call{Vacia}{\null}$}\Comment{$\Theta$(1)}
	\EndFor
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $3\Theta(1) + \Theta(\#categorias(ac)) = \Theta(\#categorias(ac))$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iAgregarLink(\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{c}{categoria})}
\begin{algorithmic}[1]
	\State $categoriaID \gets$ \Call{id}{$s.aCategorias, c$}\Comment{O(|c|)}
	\Statex
	\var{info}{infoLink}
	\State $info.categoria \gets c$\Comment{O(|c|)}
	\State $info.accesos \gets$ \Call{Vacia}{\null}\Comment{O(1)}
	\State \Call{Definir}{$s.infoLinks, l, info$}\Comment{O(|$l$|)}
	\Statex
	\State $it \gets$ \Call{CrearItPadres}{$s.aCategorias, c$}\Comment{O(|c|)}
	\Repeat
		\State \Call{AgregarAtras}{$s.linksPorCat[categoriaID-1], l$}\Comment{O(1) ya que se est\'a pasando por referencia}
		\State \Call{Subir}{$it$}\Comment{O(1)}
    	\State $categoriaID \gets$ \Call{ActualID}{$s, categoriaID$}\Comment{O(1)}
	\Until{$\neg\Call{HayMas?}{$it$}$}\Comment{$(O(h) + O(1)) * 3O(1) = O(h)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1) + 3O(|c|) + O(|l|) + O(h) = O(|c|) + O(|l|) + O(h) = O(|c| + |l| + h)$
\\ \tab El bucle tiene $h$ iteraciones ya que se comienza en un nodo y luego, en cada ciclo, se va subiendo hasta la raiz del \'arbol.
\end{algorithm}

\begin{algorithm}[H]
\caption*{iAccederLink(\Inout{s}{LinkLinkIt}, \In{l}{link}, \In{f}{fecha})}
\begin{algorithmic}[1]
	\State $link \gets$ \Call{Obtener}{$s.infoLinks, l$}\Comment{O(|$l$|)}
	\State \Call{AgregarAtras}{$link.accesos, f$}\Comment{O(1)}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(1) + O(|l|) = O(|l|)$
\textbf{ \\ \\ Falta que agregue el acceso a las categorias superiores (padres)
de ésta categoria. Para eso se le agrega esa info al arbol, y luego la complejidad va a
quedar O(|l| + h) (Requerido par hacer iLinksOrdenadosPorAccesos)}
\end{algorithm}

\begin{algorithm}[H]
\caption*{iCantLinks(\In{s}{LinkLinkIt}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{Nat}}
\begin{algorithmic}[1]
	\State $categoriaID \gets$ \Call{ID}{$s.aCategorias, c$}\Comment{$O(|c|)$}
	\State $res \gets \#s.linksPorCat[categoriaID]$\Comment{$2O(1) = O(1)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $O(|c|) + O(1) = O(|c|)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iLinksOrdenadosPorAccesos(\Inout{s}{LinkLinkIt}, \In{c}{categoria}) $\DRef res$ : \TipoVariable{itLinks}}
\begin{algorithmic}[1]
	\State $res$
\end{algorithmic}
\end{algorithm}

\end{Algoritmos}


\section{M\'odulo Iterador Unidireccional($\alpha$)}

\begin{Interfaz}

	\textbf{par\'ametro formal}: \TipoVariable{$\alpha$}.

	\textbf{usa}: \TipoVariable{Bool, lista($\alpha$), itLista($\alpha$)}.

	\textbf{se explica con}: \TipoVariable{Iterador Unidireccional($\alpha$)}.

	\textbf{g\'eneros}: \TipoVariable{iteradorUni($\alpha$)}
	
	\modTitulo{Operaciones b\'asicas}

	\InterfazFuncion{crearIterador}{\In{l}{lista($\alpha$)}}{iteradorUni($\alpha$)}
	  {$res \igobs crearItUni(l)$}
	  [$\Theta(1)$]
	  [Crea un iterador unidireccional a la lista de forma tal que al pedir actual se obtenga el primer elemento de l]

	\InterfazFuncion{HayMas?}{\In{it}{iteradorUni($\alpha$)}}{Bool}
	  {$res \igobs HayMas?(it)$}
	  [$\Theta(1)$]
	  [Devuelve true si y solo si en el iterador todav\'ia quedan elementos para iterar]

	\InterfazFuncion{Siguiente}{\Inout{it}{iteradorUni($\alpha$)}}{}
	  [$hayMas?(it) \land it \igobs it_0$]
	  {$it \igobs Avanzar(it_0)$}
	  [$\Theta(1)$]
	  [Avanza al iterador a la siguiente posici\'on.]
	  
	 \InterfazFuncion{Actual}{\In{it}{iteradorUni($\alpha$)}}{$\alpha$}
	  {$res \igobs Actual(it)$}
	  [$\Theta(1)$]
	  [Devuelve elemeno al que esta apuntando el iterador por referencia, dicho elemento no debe ser modificado ya que modificaria la lista y eso no esta permitido]

\end{Interfaz}

\begin{Representacion}

	\begin{Estructura}{iteradorUni($\alpha$)}
		\begin{Tupla}
			\tupItem{it}{itLista($\alpha$)}
		\end{Tupla}
	\end{Estructura}

\end{Representacion}

\begin{Justificacion}
\\Para representar el iterador unidireccional de la lista decidimos usar el iterador bidireccional que nos provee la lista enlazada y obtener del iterador las operaciones que necesitabamos.

\end{Justificacion}

\begin{Algoritmos}

\begin{algorithm}[H]
\caption*{iCrearIterador(\In{l}{lista($\alpha$)}) $\DRef res$ : \TipoVariable{iteradorUni($\alpha$)}}
\begin{algorithmic}[1]
	\State $res.it \gets$ \Call{CrearIt}{$l$}\Comment{$\Theta(1)$}
\end{algorithmic}
\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iHayMas?(\In{iterador}{iteradorUni($\alpha$)}) $\DRef res$ : \TipoVariable{Bool}}
\begin{algorithmic}[1]
	\State $res \gets$ \Call{HaySiguiente}{$iterador.it$}\Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iSiguiente(\Inout{iterador}{iteradorUni($\alpha$)})}
\begin{algorithmic}[1]
	\State \Call{Avanzar}{$iterador.it$}\Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption*{iActual(\In{iterador}{iteradorUni($\alpha$)}) $\DRef res$ : {$\alpha$}}
\begin{algorithmic}[1]
	\State $res \gets$ \Call{Siguiente}{$iterador.it$}\Comment{$\Theta(1)$}
\end{algorithmic}
	\textbf{C\'alculo de complejidad}: $\Theta(1)$
\end{algorithm}

\end{Algoritmos}

\begin{Servicios Usados}

\textbf{Los siguientes m\'odulos deben cumplir los compromisos pedidos a continuaci\'on:}

\modTitulo{itLista($\alpha$)}

La función crearIt debe tener complejidad O(1)\\
La función haySiguiente? debe tener complejidad O(1)\\
La función avanzar debe tener complejidad O(1)\\
La función siguiente debe tener complejidad O(1)

\end{Servicios Usados}

\end{document}